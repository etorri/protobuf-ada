-- Generated by the protocol buffer compiler.  DO NOT EDIT!
-- source: unittest.proto

pragma Ada_2012;

with Unittest.ForeignMessage;
with Unittest.ImportMessage;
with Unittest.PublicImportMessage;
with Unittest.TestAllTypes.NestedMessage;

package body Unittest.TestAllTypes is
  ---------------------------------------------------------------------------
  -- Inherited functions and procedures from Protocol_Buffers.Message -------
  ---------------------------------------------------------------------------

  procedure Clear
    (The_Message : in out Unittest.TestAllTypes.Instance) is
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      The_Message.Optional_Int32 := 0;
      The_Message.Optional_Int64 := 0;
      The_Message.Optional_Uint32 := 0;
      The_Message.Optional_Uint64 := 0;
      The_Message.Optional_Sint32 := 0;
      The_Message.Optional_Sint64 := 0;
      The_Message.Optional_Fixed32 := 0;
      The_Message.Optional_Fixed64 := 0;
    end if;
    if (The_Message.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      The_Message.Optional_Sfixed32 := 0;
      The_Message.Optional_Sfixed64 := 0;
      The_Message.Optional_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
      The_Message.Optional_Double := Protocol_Buffers.Wire_Format.PB_Double (0.00000000000000);
      The_Message.Optional_Bool := False;
      if The_Message.Has_Optional_String then
        The_Message.Clear_Has_Optional_String;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.Optional_String);
          end if;
        end;
        The_Message.Optional_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Optional_Bytes then
        The_Message.Clear_Has_Optional_Bytes;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.Optional_Bytes);
          end if;
        end;
        The_Message.Optional_Bytes := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Optional_Nested_Message then
        The_Message.Clear_Has_Optional_Nested_Message;
        declare
          Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Nested_Message);
        begin
          Protocol_Buffers.Message.Free (Temp);
          The_Message.Optional_Nested_Message := null;
        end;
      end if;
    end if;
    if (The_Message.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      if The_Message.Has_Optional_Foreign_Message then
        The_Message.Clear_Has_Optional_Foreign_Message;
        declare
          Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Foreign_Message);
        begin
          Protocol_Buffers.Message.Free (Temp);
          The_Message.Optional_Foreign_Message := null;
        end;
      end if;
      if The_Message.Has_Optional_Import_Message then
        The_Message.Clear_Has_Optional_Import_Message;
        declare
          Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Import_Message);
        begin
          Protocol_Buffers.Message.Free (Temp);
          The_Message.Optional_Import_Message := null;
        end;
      end if;
      The_Message.Optional_Nested_Enum := NestedEnum'(FOO);
      The_Message.Optional_Foreign_Enum := ForeignEnum'(FOREIGN_FOO);
      The_Message.Optional_Import_Enum := ImportEnum'(IMPORT_FOO);
      if The_Message.Has_Optional_String_Piece then
        The_Message.Clear_Has_Optional_String_Piece;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.Optional_String_Piece);
          end if;
        end;
        The_Message.Optional_String_Piece := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Optional_Cord then
        The_Message.Clear_Has_Optional_Cord;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.Optional_Cord);
          end if;
        end;
        The_Message.Optional_Cord := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Optional_Public_Import_Message then
        The_Message.Clear_Has_Optional_Public_Import_Message;
        declare
          Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Public_Import_Message);
        begin
          Protocol_Buffers.Message.Free (Temp);
          The_Message.Optional_Public_Import_Message := null;
        end;
      end if;
    end if;
    if (The_Message.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      if The_Message.Has_Optional_Lazy_Message then
        The_Message.Clear_Has_Optional_Lazy_Message;
        declare
          Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Lazy_Message);
        begin
          Protocol_Buffers.Message.Free (Temp);
          The_Message.Optional_Lazy_Message := null;
        end;
      end if;
    end if;
    if (The_Message.Has_Bits (49 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 49 mod 32)) /= 0 then
      The_Message.Default_Int32 := 41;
      The_Message.Default_Int64 := 42;
      The_Message.Default_Uint32 := 43;
      The_Message.Default_Uint64 := 44;
      The_Message.Default_Sint32 := -45;
      The_Message.Default_Sint64 := 46;
      The_Message.Default_Fixed32 := 47;
    end if;
    if (The_Message.Has_Bits (56 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 56 mod 32)) /= 0 then
      The_Message.Default_Fixed64 := 48;
      The_Message.Default_Sfixed32 := 49;
      The_Message.Default_Sfixed64 := -50;
      The_Message.Default_Float := Protocol_Buffers.Wire_Format.PB_Float (51.5000);
      The_Message.Default_Double := Protocol_Buffers.Wire_Format.PB_Double (52000.0000000000);
      The_Message.Default_Bool := True;
      if The_Message.Has_Default_String then
        The_Message.Clear_Has_Default_String;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Default_String /= Default_Default_String'Access then
            Free (The_Message.Default_String);
          end if;
        end;
        The_Message.Default_String := Default_Default_String'Access;
      end if;
      if The_Message.Has_Default_Bytes then
        The_Message.Clear_Has_Default_Bytes;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
            Free (The_Message.Default_Bytes);
          end if;
        end;
        The_Message.Default_Bytes := Default_Default_Bytes'Access;
      end if;
    end if;
    if (The_Message.Has_Bits (64 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 64 mod 32)) /= 0 then
      The_Message.Default_Nested_Enum := NestedEnum'(BAR);
      The_Message.Default_Foreign_Enum := ForeignEnum'(FOREIGN_BAR);
      The_Message.Default_Import_Enum := ImportEnum'(IMPORT_BAR);
      if The_Message.Has_Default_String_Piece then
        The_Message.Clear_Has_Default_String_Piece;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
            Free (The_Message.Default_String_Piece);
          end if;
        end;
        The_Message.Default_String_Piece := Default_Default_String_Piece'Access;
      end if;
      if The_Message.Has_Default_Cord then
        The_Message.Clear_Has_Default_Cord;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Default_Cord /= Default_Default_Cord'Access then
            Free (The_Message.Default_Cord);
          end if;
        end;
        The_Message.Default_Cord := Default_Default_Cord'Access;
      end if;
    end if;
    The_Message.Repeated_Int32.Clear;
    The_Message.Repeated_Int64.Clear;
    The_Message.Repeated_Uint32.Clear;
    The_Message.Repeated_Uint64.Clear;
    The_Message.Repeated_Sint32.Clear;
    The_Message.Repeated_Sint64.Clear;
    The_Message.Repeated_Fixed32.Clear;
    The_Message.Repeated_Fixed64.Clear;
    The_Message.Repeated_Sfixed32.Clear;
    The_Message.Repeated_Sfixed64.Clear;
    The_Message.Repeated_Float.Clear;
    The_Message.Repeated_Double.Clear;
    The_Message.Repeated_Bool.Clear;
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String.Clear;

    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Bytes loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Bytes.Clear;

    for C in The_Message.Repeated_Nested_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Nested_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Nested_Message.Clear;

    for C in The_Message.Repeated_Foreign_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Foreign_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Foreign_Message.Clear;

    for C in The_Message.Repeated_Import_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Import_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Import_Message.Clear;

    The_Message.Repeated_Nested_Enum.Clear;
    The_Message.Repeated_Foreign_Enum.Clear;
    The_Message.Repeated_Import_Enum.Clear;
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String_Piece loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String_Piece.Clear;

    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Cord loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Cord.Clear;

    for C in The_Message.Repeated_Lazy_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Lazy_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Lazy_Message.Clear;

    The_Message.Has_Bits := (others => 0);
  end Clear;

  procedure Copy
    (To   : in out Unittest.TestAllTypes.Instance;
     From : in Unittest.TestAllTypes.Instance) is
  begin
    To.Clear;
    To.Merge (From);
  end Copy;

  function Get_Type_Name
    (The_Message : in Unittest.TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return "protobuf_unittest.TestAllTypes";
  end Get_Type_Name;

  function Is_Initialized
    (The_Message : in Unittest.TestAllTypes.Instance) return Boolean is
  begin
    return True;
  end Is_Initialized;

  procedure Merge
    (To   : in out Unittest.TestAllTypes.Instance;
     From : in Unittest.TestAllTypes.Instance) is
  begin
    To.Repeated_Int32.Append(From.Repeated_Int32);
    To.Repeated_Int64.Append(From.Repeated_Int64);
    To.Repeated_Uint32.Append(From.Repeated_Uint32);
    To.Repeated_Uint64.Append(From.Repeated_Uint64);
    To.Repeated_Sint32.Append(From.Repeated_Sint32);
    To.Repeated_Sint64.Append(From.Repeated_Sint64);
    To.Repeated_Fixed32.Append(From.Repeated_Fixed32);
    To.Repeated_Fixed64.Append(From.Repeated_Fixed64);
    To.Repeated_Sfixed32.Append(From.Repeated_Sfixed32);
    To.Repeated_Sfixed64.Append(From.Repeated_Sfixed64);
    To.Repeated_Float.Append(From.Repeated_Float);
    To.Repeated_Double.Append(From.Repeated_Double);
    To.Repeated_Bool.Append(From.Repeated_Bool);
    for E of From.Repeated_String loop
      To.Repeated_String.Append (new Protocol_Buffers.Wire_Format.PB_String'(E.all));
    end loop;
    for E of From.Repeated_Bytes loop
      To.Repeated_Bytes.Append (new Protocol_Buffers.Wire_Format.PB_String'(E.all));
    end loop;
    declare
      Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
    begin
      for E of From.Repeated_Nested_Message loop
        Temp := new Unittest.TestAllTypes.NestedMessage.Instance;
        Temp.Merge (Unittest.TestAllTypes.NestedMessage.Instance (E.all));
        To.Repeated_Nested_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
      end loop;
    end;
    declare
      Temp : Unittest.ForeignMessage.ForeignMessage_Access;
    begin
      for E of From.Repeated_Foreign_Message loop
        Temp := new Unittest.ForeignMessage.Instance;
        Temp.Merge (Unittest.ForeignMessage.Instance (E.all));
        To.Repeated_Foreign_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
      end loop;
    end;
    declare
      Temp : Unittest.ImportMessage.ImportMessage_Access;
    begin
      for E of From.Repeated_Import_Message loop
        Temp := new Unittest.ImportMessage.Instance;
        Temp.Merge (Unittest.ImportMessage.Instance (E.all));
        To.Repeated_Import_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
      end loop;
    end;
    To.Repeated_Nested_Enum.Append (From.Repeated_Nested_Enum);
    To.Repeated_Foreign_Enum.Append (From.Repeated_Foreign_Enum);
    To.Repeated_Import_Enum.Append (From.Repeated_Import_Enum);
    for E of From.Repeated_String_Piece loop
      To.Repeated_String_Piece.Append (new Protocol_Buffers.Wire_Format.PB_String'(E.all));
    end loop;
    for E of From.Repeated_Cord loop
      To.Repeated_Cord.Append (new Protocol_Buffers.Wire_Format.PB_String'(E.all));
    end loop;
    declare
      Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
    begin
      for E of From.Repeated_Lazy_Message loop
        Temp := new Unittest.TestAllTypes.NestedMessage.Instance;
        Temp.Merge (Unittest.TestAllTypes.NestedMessage.Instance (E.all));
        To.Repeated_Lazy_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
      end loop;
    end;
    if (From.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional int32 optional_int32 = 1;
      if From.Has_Optional_Int32 then
        To.Set_Optional_Int32 (From.Optional_Int32);
      end if;
      -- optional int64 optional_int64 = 2;
      if From.Has_Optional_Int64 then
        To.Set_Optional_Int64 (From.Optional_Int64);
      end if;
      -- optional uint32 optional_uint32 = 3;
      if From.Has_Optional_Uint32 then
        To.Set_Optional_Uint32 (From.Optional_Uint32);
      end if;
      -- optional uint64 optional_uint64 = 4;
      if From.Has_Optional_Uint64 then
        To.Set_Optional_Uint64 (From.Optional_Uint64);
      end if;
      -- optional sint32 optional_sint32 = 5;
      if From.Has_Optional_Sint32 then
        To.Set_Optional_Sint32 (From.Optional_Sint32);
      end if;
      -- optional sint64 optional_sint64 = 6;
      if From.Has_Optional_Sint64 then
        To.Set_Optional_Sint64 (From.Optional_Sint64);
      end if;
      -- optional fixed32 optional_fixed32 = 7;
      if From.Has_Optional_Fixed32 then
        To.Set_Optional_Fixed32 (From.Optional_Fixed32);
      end if;
      -- optional fixed64 optional_fixed64 = 8;
      if From.Has_Optional_Fixed64 then
        To.Set_Optional_Fixed64 (From.Optional_Fixed64);
      end if;
    end if;
    if (From.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      -- optional sfixed32 optional_sfixed32 = 9;
      if From.Has_Optional_Sfixed32 then
        To.Set_Optional_Sfixed32 (From.Optional_Sfixed32);
      end if;
      -- optional sfixed64 optional_sfixed64 = 10;
      if From.Has_Optional_Sfixed64 then
        To.Set_Optional_Sfixed64 (From.Optional_Sfixed64);
      end if;
      -- optional float optional_float = 11;
      if From.Has_Optional_Float then
        To.Set_Optional_Float (From.Optional_Float);
      end if;
      -- optional double optional_double = 12;
      if From.Has_Optional_Double then
        To.Set_Optional_Double (From.Optional_Double);
      end if;
      -- optional bool optional_bool = 13;
      if From.Has_Optional_Bool then
        To.Set_Optional_Bool (From.Optional_Bool);
      end if;
      -- optional string optional_string = 14;
      if From.Has_Optional_String then
        To.Set_Optional_String(From.Get_Optional_String);
      end if;
      -- optional bytes optional_bytes = 15;
      if From.Has_Optional_Bytes then
        To.Set_Optional_Bytes(From.Get_Optional_Bytes);
      end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
      if From.Has_Optional_Nested_Message then
        To.Get_Optional_Nested_Message.Merge (From.Optional_Nested_Message.all);
      end if;
    end if;
    if (From.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      -- optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;
      if From.Has_Optional_Foreign_Message then
        To.Get_Optional_Foreign_Message.Merge (From.Optional_Foreign_Message.all);
      end if;
      -- optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;
      if From.Has_Optional_Import_Message then
        To.Get_Optional_Import_Message.Merge (From.Optional_Import_Message.all);
      end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
      if From.Has_Optional_Nested_Enum then
        To.Set_Optional_Nested_Enum (From.Optional_Nested_Enum);
      end if;
      -- optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
      if From.Has_Optional_Foreign_Enum then
        To.Set_Optional_Foreign_Enum (From.Optional_Foreign_Enum);
      end if;
      -- optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;
      if From.Has_Optional_Import_Enum then
        To.Set_Optional_Import_Enum (From.Optional_Import_Enum);
      end if;
      -- optional string optional_string_piece = 24 [ctype = STRING_PIECE];
      if From.Has_Optional_String_Piece then
        To.Set_Optional_String_Piece(From.Get_Optional_String_Piece);
      end if;
      -- optional string optional_cord = 25 [ctype = CORD];
      if From.Has_Optional_Cord then
        To.Set_Optional_Cord(From.Get_Optional_Cord);
      end if;
      -- optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
      if From.Has_Optional_Public_Import_Message then
        To.Get_Optional_Public_Import_Message.Merge (From.Optional_Public_Import_Message.all);
      end if;
    end if;
    if (From.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27 [lazy = true];
      if From.Has_Optional_Lazy_Message then
        To.Get_Optional_Lazy_Message.Merge (From.Optional_Lazy_Message.all);
      end if;
    end if;
    if (From.Has_Bits (49 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 49 mod 32)) /= 0 then
      -- optional int32 default_int32 = 61 [default = 41];
      if From.Has_Default_Int32 then
        To.Set_Default_Int32 (From.Default_Int32);
      end if;
      -- optional int64 default_int64 = 62 [default = 42];
      if From.Has_Default_Int64 then
        To.Set_Default_Int64 (From.Default_Int64);
      end if;
      -- optional uint32 default_uint32 = 63 [default = 43];
      if From.Has_Default_Uint32 then
        To.Set_Default_Uint32 (From.Default_Uint32);
      end if;
      -- optional uint64 default_uint64 = 64 [default = 44];
      if From.Has_Default_Uint64 then
        To.Set_Default_Uint64 (From.Default_Uint64);
      end if;
      -- optional sint32 default_sint32 = 65 [default = -45];
      if From.Has_Default_Sint32 then
        To.Set_Default_Sint32 (From.Default_Sint32);
      end if;
      -- optional sint64 default_sint64 = 66 [default = 46];
      if From.Has_Default_Sint64 then
        To.Set_Default_Sint64 (From.Default_Sint64);
      end if;
      -- optional fixed32 default_fixed32 = 67 [default = 47];
      if From.Has_Default_Fixed32 then
        To.Set_Default_Fixed32 (From.Default_Fixed32);
      end if;
    end if;
    if (From.Has_Bits (56 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 56 mod 32)) /= 0 then
      -- optional fixed64 default_fixed64 = 68 [default = 48];
      if From.Has_Default_Fixed64 then
        To.Set_Default_Fixed64 (From.Default_Fixed64);
      end if;
      -- optional sfixed32 default_sfixed32 = 69 [default = 49];
      if From.Has_Default_Sfixed32 then
        To.Set_Default_Sfixed32 (From.Default_Sfixed32);
      end if;
      -- optional sfixed64 default_sfixed64 = 70 [default = -50];
      if From.Has_Default_Sfixed64 then
        To.Set_Default_Sfixed64 (From.Default_Sfixed64);
      end if;
      -- optional float default_float = 71 [default = 51.5];
      if From.Has_Default_Float then
        To.Set_Default_Float (From.Default_Float);
      end if;
      -- optional double default_double = 72 [default = 52000];
      if From.Has_Default_Double then
        To.Set_Default_Double (From.Default_Double);
      end if;
      -- optional bool default_bool = 73 [default = true];
      if From.Has_Default_Bool then
        To.Set_Default_Bool (From.Default_Bool);
      end if;
      -- optional string default_string = 74 [default = "hello"];
      if From.Has_Default_String then
        To.Set_Default_String(From.Get_Default_String);
      end if;
      -- optional bytes default_bytes = 75 [default = "world"];
      if From.Has_Default_Bytes then
        To.Set_Default_Bytes(From.Get_Default_Bytes);
      end if;
    end if;
    if (From.Has_Bits (64 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 64 mod 32)) /= 0 then
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
      if From.Has_Default_Nested_Enum then
        To.Set_Default_Nested_Enum (From.Default_Nested_Enum);
      end if;
      -- optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
      if From.Has_Default_Foreign_Enum then
        To.Set_Default_Foreign_Enum (From.Default_Foreign_Enum);
      end if;
      -- optional .protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
      if From.Has_Default_Import_Enum then
        To.Set_Default_Import_Enum (From.Default_Import_Enum);
      end if;
      -- optional string default_string_piece = 84 [default = "abc", ctype = STRING_PIECE];
      if From.Has_Default_String_Piece then
        To.Set_Default_String_Piece(From.Get_Default_String_Piece);
      end if;
      -- optional string default_cord = 85 [default = "123", ctype = CORD];
      if From.Has_Default_Cord then
        To.Set_Default_Cord(From.Get_Default_Cord);
      end if;
    end if;
  end Merge;

  function Byte_Size
    (The_Message : in out Unittest.TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
    Total_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional int32 optional_int32 = 1;
      if The_Message.Has_Optional_Int32 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (The_Message.Optional_Int32);
      end if;
      -- optional int64 optional_int64 = 2;
      if The_Message.Has_Optional_Int64 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (The_Message.Optional_Int64);
      end if;
      -- optional uint32 optional_uint32 = 3;
      if The_Message.Has_Optional_Uint32 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_32_Size_No_Tag (The_Message.Optional_Uint32);
      end if;
      -- optional uint64 optional_uint64 = 4;
      if The_Message.Has_Optional_Uint64 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_64_Size_No_Tag (The_Message.Optional_Uint64);
      end if;
      -- optional sint32 optional_sint32 = 5;
      if The_Message.Has_Optional_Sint32 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_32_Size_No_Tag (The_Message.Optional_Sint32);
      end if;
      -- optional sint64 optional_sint64 = 6;
      if The_Message.Has_Optional_Sint64 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_64_Size_No_Tag (The_Message.Optional_Sint64);
      end if;
      -- optional fixed32 optional_fixed32 = 7;
      if The_Message.Has_Optional_Fixed32 then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional fixed64 optional_fixed64 = 8;
      if The_Message.Has_Optional_Fixed64 then
        Total_Size := Total_Size + 1 + 8;
      end if;
    end if;
    if (The_Message.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      -- optional sfixed32 optional_sfixed32 = 9;
      if The_Message.Has_Optional_Sfixed32 then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional sfixed64 optional_sfixed64 = 10;
      if The_Message.Has_Optional_Sfixed64 then
        Total_Size := Total_Size + 1 + 8;
      end if;
      -- optional float optional_float = 11;
      if The_Message.Has_Optional_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional double optional_double = 12;
      if The_Message.Has_Optional_Double then
        Total_Size := Total_Size + 1 + 8;
      end if;
      -- optional bool optional_bool = 13;
      if The_Message.Has_Optional_Bool then
        Total_Size := Total_Size + 1 + 1;
      end if;
      -- optional string optional_string = 14;
      if The_Message.Has_Optional_String then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Optional_String.all);
      end if;
      -- optional bytes optional_bytes = 15;
      if The_Message.Has_Optional_Bytes then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Optional_Bytes.all);
      end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
      if The_Message.Has_Optional_Nested_Message then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Optional_Nested_Message.all);
      end if;
    end if;
    if (The_Message.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      -- optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;
      if The_Message.Has_Optional_Foreign_Message then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Optional_Foreign_Message.all);
      end if;
      -- optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;
      if The_Message.Has_Optional_Import_Message then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Optional_Import_Message.all);
      end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
      if The_Message.Has_Optional_Nested_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Optional_Nested_Enum));
      end if;
      -- optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
      if The_Message.Has_Optional_Foreign_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Optional_Foreign_Enum));
      end if;
      -- optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;
      if The_Message.Has_Optional_Import_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Optional_Import_Enum));
      end if;
      -- optional string optional_string_piece = 24 [ctype = STRING_PIECE];
      if The_Message.Has_Optional_String_Piece then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Optional_String_Piece.all);
      end if;
      -- optional string optional_cord = 25 [ctype = CORD];
      if The_Message.Has_Optional_Cord then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Optional_Cord.all);
      end if;
      -- optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
      if The_Message.Has_Optional_Public_Import_Message then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Optional_Public_Import_Message.all);
      end if;
    end if;
    if (The_Message.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27 [lazy = true];
      if The_Message.Has_Optional_Lazy_Message then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Optional_Lazy_Message.all);
      end if;
    end if;
    if (The_Message.Has_Bits (49 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 49 mod 32)) /= 0 then
      -- optional int32 default_int32 = 61 [default = 41];
      if The_Message.Has_Default_Int32 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (The_Message.Default_Int32);
      end if;
      -- optional int64 default_int64 = 62 [default = 42];
      if The_Message.Has_Default_Int64 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (The_Message.Default_Int64);
      end if;
      -- optional uint32 default_uint32 = 63 [default = 43];
      if The_Message.Has_Default_Uint32 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_32_Size_No_Tag (The_Message.Default_Uint32);
      end if;
      -- optional uint64 default_uint64 = 64 [default = 44];
      if The_Message.Has_Default_Uint64 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_64_Size_No_Tag (The_Message.Default_Uint64);
      end if;
      -- optional sint32 default_sint32 = 65 [default = -45];
      if The_Message.Has_Default_Sint32 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_32_Size_No_Tag (The_Message.Default_Sint32);
      end if;
      -- optional sint64 default_sint64 = 66 [default = 46];
      if The_Message.Has_Default_Sint64 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_64_Size_No_Tag (The_Message.Default_Sint64);
      end if;
      -- optional fixed32 default_fixed32 = 67 [default = 47];
      if The_Message.Has_Default_Fixed32 then
        Total_Size := Total_Size + 2 + 4;
      end if;
    end if;
    if (The_Message.Has_Bits (56 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 56 mod 32)) /= 0 then
      -- optional fixed64 default_fixed64 = 68 [default = 48];
      if The_Message.Has_Default_Fixed64 then
        Total_Size := Total_Size + 2 + 8;
      end if;
      -- optional sfixed32 default_sfixed32 = 69 [default = 49];
      if The_Message.Has_Default_Sfixed32 then
        Total_Size := Total_Size + 2 + 4;
      end if;
      -- optional sfixed64 default_sfixed64 = 70 [default = -50];
      if The_Message.Has_Default_Sfixed64 then
        Total_Size := Total_Size + 2 + 8;
      end if;
      -- optional float default_float = 71 [default = 51.5];
      if The_Message.Has_Default_Float then
        Total_Size := Total_Size + 2 + 4;
      end if;
      -- optional double default_double = 72 [default = 52000];
      if The_Message.Has_Default_Double then
        Total_Size := Total_Size + 2 + 8;
      end if;
      -- optional bool default_bool = 73 [default = true];
      if The_Message.Has_Default_Bool then
        Total_Size := Total_Size + 2 + 1;
      end if;
      -- optional string default_string = 74 [default = "hello"];
      if The_Message.Has_Default_String then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Default_String.all);
      end if;
      -- optional bytes default_bytes = 75 [default = "world"];
      if The_Message.Has_Default_Bytes then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Default_Bytes.all);
      end if;
    end if;
    if (The_Message.Has_Bits (64 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 64 mod 32)) /= 0 then
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
      if The_Message.Has_Default_Nested_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Default_Nested_Enum));
      end if;
      -- optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
      if The_Message.Has_Default_Foreign_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Default_Foreign_Enum));
      end if;
      -- optional .protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
      if The_Message.Has_Default_Import_Enum then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Enumeration_To_PB_Int32(The_Message.Default_Import_Enum));
      end if;
      -- optional string default_string_piece = 84 [default = "abc", ctype = STRING_PIECE];
      if The_Message.Has_Default_String_Piece then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Default_String_Piece.all);
      end if;
      -- optional string default_cord = 85 [default = "123", ctype = CORD];
      if The_Message.Has_Default_Cord then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Default_Cord.all);
      end if;
    end if;
    -- repeated int32 repeated_int32 = 31;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Int32 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Int32_Size + Data_Size;
    end;

    -- repeated int64 repeated_int64 = 32;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Int64 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Int64_Size + Data_Size;
    end;

    -- repeated uint32 repeated_uint32 = 33;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Uint32 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Uint32_Size + Data_Size;
    end;

    -- repeated uint64 repeated_uint64 = 34;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Uint64 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_64_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Uint64_Size + Data_Size;
    end;

    -- repeated sint32 repeated_sint32 = 35;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Sint32 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Sint32_Size + Data_Size;
    end;

    -- repeated sint64 repeated_sint64 = 36;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Sint64 loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Signed_Integer_64_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Sint64_Size + Data_Size;
    end;

    -- repeated fixed32 repeated_fixed32 = 37;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 4 * The_Message.Repeated_Fixed32_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Fixed32_Size + Data_Size;
    end;

    -- repeated fixed64 repeated_fixed64 = 38;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 8 * The_Message.Repeated_Fixed64_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Fixed64_Size + Data_Size;
    end;

    -- repeated sfixed32 repeated_sfixed32 = 39;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 4 * The_Message.Repeated_Sfixed32_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Sfixed32_Size + Data_Size;
    end;

    -- repeated sfixed64 repeated_sfixed64 = 40;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 8 * The_Message.Repeated_Sfixed64_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Sfixed64_Size + Data_Size;
    end;

    -- repeated float repeated_float = 41;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 4 * The_Message.Repeated_Float_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Float_Size + Data_Size;
    end;

    -- repeated double repeated_double = 42;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 8 * The_Message.Repeated_Double_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Double_Size + Data_Size;
    end;

    -- repeated bool repeated_bool = 43;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      Data_Size := 1 * The_Message.Repeated_Bool_Size;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Bool_Size + Data_Size;
    end;

    -- repeated string repeated_string = 44;
    Total_Size := Total_Size + 2 * The_Message.Repeated_String_Size;
    for E of The_Message.Repeated_String loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    -- repeated bytes repeated_bytes = 45;
    Total_Size := Total_Size + 2 * The_Message.Repeated_Bytes_Size;
    for E of The_Message.Repeated_Bytes loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
    Total_Size := Total_Size + 2 * The_Message.Repeated_Nested_Message_Size;
    for E of The_Message.Repeated_Nested_Message loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
    Total_Size := Total_Size + 2 * The_Message.Repeated_Foreign_Message_Size;
    for E of The_Message.Repeated_Foreign_Message loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .protobuf_unittest_import.ImportMessage repeated_import_message = 50;
    Total_Size := Total_Size + 2 * The_Message.Repeated_Import_Message_Size;
    for E of The_Message.Repeated_Import_Message loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Nested_Enum loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Nested_Enum_Size + Data_Size;
    end;

    -- repeated .protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Foreign_Enum loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Foreign_Enum_Size + Data_Size;
    end;

    -- repeated .protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
    declare
      Data_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
    begin
      for E of The_Message.Repeated_Import_Enum loop
        Data_Size := Data_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
      end loop;
      Total_Size := Total_Size + 2 * The_Message.Repeated_Import_Enum_Size + Data_Size;
    end;

    -- repeated string repeated_string_piece = 54 [ctype = STRING_PIECE];
    Total_Size := Total_Size + 2 * The_Message.Repeated_String_Piece_Size;
    for E of The_Message.Repeated_String_Piece loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    -- repeated string repeated_cord = 55 [ctype = CORD];
    Total_Size := Total_Size + 2 * The_Message.Repeated_Cord_Size;
    for E of The_Message.Repeated_Cord loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57 [lazy = true];
    Total_Size := Total_Size + 2 * The_Message.Repeated_Lazy_Message_Size;
    for E of The_Message.Repeated_Lazy_Message loop
      Total_Size := Total_Size + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    The_Message.Cached_Size := Total_Size;
    return Total_Size;
  end Byte_Size;

  procedure Serialize_With_Cached_Sizes
    (The_Message   : in Unittest.TestAllTypes.Instance;
     The_Coded_Output_Stream : in
       Protocol_Buffers.IO.Coded_Output_Stream.Instance) is
  begin
    -- optional int32 optional_int32 = 1;
    if The_Message.Has_Optional_Int32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 1, The_Message.Optional_Int32);
    end if;
    -- optional int64 optional_int64 = 2;
    if The_Message.Has_Optional_Int64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_64 (The_Coded_Output_Stream, 2, The_Message.Optional_Int64);
    end if;
    -- optional uint32 optional_uint32 = 3;
    if The_Message.Has_Optional_Uint32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_32 (The_Coded_Output_Stream, 3, The_Message.Optional_Uint32);
    end if;
    -- optional uint64 optional_uint64 = 4;
    if The_Message.Has_Optional_Uint64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_64 (The_Coded_Output_Stream, 4, The_Message.Optional_Uint64);
    end if;
    -- optional sint32 optional_sint32 = 5;
    if The_Message.Has_Optional_Sint32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Integer_32 (The_Coded_Output_Stream, 5, The_Message.Optional_Sint32);
    end if;
    -- optional sint64 optional_sint64 = 6;
    if The_Message.Has_Optional_Sint64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Integer_64 (The_Coded_Output_Stream, 6, The_Message.Optional_Sint64);
    end if;
    -- optional fixed32 optional_fixed32 = 7;
    if The_Message.Has_Optional_Fixed32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Fixed_32 (The_Coded_Output_Stream, 7, The_Message.Optional_Fixed32);
    end if;
    -- optional fixed64 optional_fixed64 = 8;
    if The_Message.Has_Optional_Fixed64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Fixed_64 (The_Coded_Output_Stream, 8, The_Message.Optional_Fixed64);
    end if;
    -- optional sfixed32 optional_sfixed32 = 9;
    if The_Message.Has_Optional_Sfixed32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Fixed_32 (The_Coded_Output_Stream, 9, The_Message.Optional_Sfixed32);
    end if;
    -- optional sfixed64 optional_sfixed64 = 10;
    if The_Message.Has_Optional_Sfixed64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Fixed_64 (The_Coded_Output_Stream, 10, The_Message.Optional_Sfixed64);
    end if;
    -- optional float optional_float = 11;
    if The_Message.Has_Optional_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 11, The_Message.Optional_Float);
    end if;
    -- optional double optional_double = 12;
    if The_Message.Has_Optional_Double then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Double (The_Coded_Output_Stream, 12, The_Message.Optional_Double);
    end if;
    -- optional bool optional_bool = 13;
    if The_Message.Has_Optional_Bool then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Boolean (The_Coded_Output_Stream, 13, The_Message.Optional_Bool);
    end if;
    -- optional string optional_string = 14;
    if The_Message.Has_Optional_String then
      The_Coded_Output_Stream.Write_String (14, The_Message.Optional_String.all);
    end if;
    -- optional bytes optional_bytes = 15;
    if The_Message.Has_Optional_Bytes then
      The_Coded_Output_Stream.Write_String (15, The_Message.Optional_Bytes.all);
    end if;
    -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
    if The_Message.Has_Optional_Nested_Message then
      The_Coded_Output_Stream.Write_Message (18, The_Message.Optional_Nested_Message.all);
    end if;
    -- optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;
    if The_Message.Has_Optional_Foreign_Message then
      The_Coded_Output_Stream.Write_Message (19, The_Message.Optional_Foreign_Message.all);
    end if;
    -- optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;
    if The_Message.Has_Optional_Import_Message then
      The_Coded_Output_Stream.Write_Message (20, The_Message.Optional_Import_Message.all);
    end if;
    -- optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
    if The_Message.Has_Optional_Nested_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 21, Enumeration_To_PB_Int32(The_Message.Optional_Nested_Enum));
    end if;
    -- optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
    if The_Message.Has_Optional_Foreign_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 22, Enumeration_To_PB_Int32(The_Message.Optional_Foreign_Enum));
    end if;
    -- optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;
    if The_Message.Has_Optional_Import_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 23, Enumeration_To_PB_Int32(The_Message.Optional_Import_Enum));
    end if;
    -- optional string optional_string_piece = 24 [ctype = STRING_PIECE];
    if The_Message.Has_Optional_String_Piece then
      The_Coded_Output_Stream.Write_String (24, The_Message.Optional_String_Piece.all);
    end if;
    -- optional string optional_cord = 25 [ctype = CORD];
    if The_Message.Has_Optional_Cord then
      The_Coded_Output_Stream.Write_String (25, The_Message.Optional_Cord.all);
    end if;
    -- optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
    if The_Message.Has_Optional_Public_Import_Message then
      The_Coded_Output_Stream.Write_Message (26, The_Message.Optional_Public_Import_Message.all);
    end if;
    -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27 [lazy = true];
    if The_Message.Has_Optional_Lazy_Message then
      The_Coded_Output_Stream.Write_Message (27, The_Message.Optional_Lazy_Message.all);
    end if;
    -- repeated int32 repeated_int32 = 31;
    for E of The_Message.Repeated_Int32 loop
      The_Coded_Output_Stream.Write_Integer_32 (31, E);
    end loop;
    -- repeated int64 repeated_int64 = 32;
    for E of The_Message.Repeated_Int64 loop
      The_Coded_Output_Stream.Write_Integer_64 (32, E);
    end loop;
    -- repeated uint32 repeated_uint32 = 33;
    for E of The_Message.Repeated_Uint32 loop
      The_Coded_Output_Stream.Write_Unsigned_Integer_32 (33, E);
    end loop;
    -- repeated uint64 repeated_uint64 = 34;
    for E of The_Message.Repeated_Uint64 loop
      The_Coded_Output_Stream.Write_Unsigned_Integer_64 (34, E);
    end loop;
    -- repeated sint32 repeated_sint32 = 35;
    for E of The_Message.Repeated_Sint32 loop
      The_Coded_Output_Stream.Write_Signed_Integer_32 (35, E);
    end loop;
    -- repeated sint64 repeated_sint64 = 36;
    for E of The_Message.Repeated_Sint64 loop
      The_Coded_Output_Stream.Write_Signed_Integer_64 (36, E);
    end loop;
    -- repeated fixed32 repeated_fixed32 = 37;
    for E of The_Message.Repeated_Fixed32 loop
      The_Coded_Output_Stream.Write_Fixed_32 (37, E);
    end loop;
    -- repeated fixed64 repeated_fixed64 = 38;
    for E of The_Message.Repeated_Fixed64 loop
      The_Coded_Output_Stream.Write_Fixed_64 (38, E);
    end loop;
    -- repeated sfixed32 repeated_sfixed32 = 39;
    for E of The_Message.Repeated_Sfixed32 loop
      The_Coded_Output_Stream.Write_Signed_Fixed_32 (39, E);
    end loop;
    -- repeated sfixed64 repeated_sfixed64 = 40;
    for E of The_Message.Repeated_Sfixed64 loop
      The_Coded_Output_Stream.Write_Signed_Fixed_64 (40, E);
    end loop;
    -- repeated float repeated_float = 41;
    for E of The_Message.Repeated_Float loop
      The_Coded_Output_Stream.Write_Float (41, E);
    end loop;
    -- repeated double repeated_double = 42;
    for E of The_Message.Repeated_Double loop
      The_Coded_Output_Stream.Write_Double (42, E);
    end loop;
    -- repeated bool repeated_bool = 43;
    for E of The_Message.Repeated_Bool loop
      The_Coded_Output_Stream.Write_Boolean (43, E);
    end loop;
    -- repeated string repeated_string = 44;
    for E of The_Message.Repeated_String loop
      The_Coded_Output_Stream.Write_String (44, E.all);
    end loop;
    -- repeated bytes repeated_bytes = 45;
    for E of The_Message.Repeated_Bytes loop
      The_Coded_Output_Stream.Write_String (45, E.all);
    end loop;
    -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
    for E of The_Message.Repeated_Nested_Message loop
      The_Coded_Output_Stream.Write_Message (48, E.all);
    end loop;
    -- repeated .protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
    for E of The_Message.Repeated_Foreign_Message loop
      The_Coded_Output_Stream.Write_Message (49, E.all);
    end loop;
    -- repeated .protobuf_unittest_import.ImportMessage repeated_import_message = 50;
    for E of The_Message.Repeated_Import_Message loop
      The_Coded_Output_Stream.Write_Message (50, E.all);
    end loop;
    -- repeated .protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
    for E of The_Message.Repeated_Nested_Enum loop
      The_Coded_Output_Stream.Write_Integer_32 (51, E);
    end loop;
    -- repeated .protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
    for E of The_Message.Repeated_Foreign_Enum loop
      The_Coded_Output_Stream.Write_Integer_32 (52, E);
    end loop;
    -- repeated .protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
    for E of The_Message.Repeated_Import_Enum loop
      The_Coded_Output_Stream.Write_Integer_32 (53, E);
    end loop;
    -- repeated string repeated_string_piece = 54 [ctype = STRING_PIECE];
    for E of The_Message.Repeated_String_Piece loop
      The_Coded_Output_Stream.Write_String (54, E.all);
    end loop;
    -- repeated string repeated_cord = 55 [ctype = CORD];
    for E of The_Message.Repeated_Cord loop
      The_Coded_Output_Stream.Write_String (55, E.all);
    end loop;
    -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57 [lazy = true];
    for E of The_Message.Repeated_Lazy_Message loop
      The_Coded_Output_Stream.Write_Message (57, E.all);
    end loop;
    -- optional int32 default_int32 = 61 [default = 41];
    if The_Message.Has_Default_Int32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 61, The_Message.Default_Int32);
    end if;
    -- optional int64 default_int64 = 62 [default = 42];
    if The_Message.Has_Default_Int64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_64 (The_Coded_Output_Stream, 62, The_Message.Default_Int64);
    end if;
    -- optional uint32 default_uint32 = 63 [default = 43];
    if The_Message.Has_Default_Uint32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_32 (The_Coded_Output_Stream, 63, The_Message.Default_Uint32);
    end if;
    -- optional uint64 default_uint64 = 64 [default = 44];
    if The_Message.Has_Default_Uint64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_64 (The_Coded_Output_Stream, 64, The_Message.Default_Uint64);
    end if;
    -- optional sint32 default_sint32 = 65 [default = -45];
    if The_Message.Has_Default_Sint32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Integer_32 (The_Coded_Output_Stream, 65, The_Message.Default_Sint32);
    end if;
    -- optional sint64 default_sint64 = 66 [default = 46];
    if The_Message.Has_Default_Sint64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Integer_64 (The_Coded_Output_Stream, 66, The_Message.Default_Sint64);
    end if;
    -- optional fixed32 default_fixed32 = 67 [default = 47];
    if The_Message.Has_Default_Fixed32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Fixed_32 (The_Coded_Output_Stream, 67, The_Message.Default_Fixed32);
    end if;
    -- optional fixed64 default_fixed64 = 68 [default = 48];
    if The_Message.Has_Default_Fixed64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Fixed_64 (The_Coded_Output_Stream, 68, The_Message.Default_Fixed64);
    end if;
    -- optional sfixed32 default_sfixed32 = 69 [default = 49];
    if The_Message.Has_Default_Sfixed32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Fixed_32 (The_Coded_Output_Stream, 69, The_Message.Default_Sfixed32);
    end if;
    -- optional sfixed64 default_sfixed64 = 70 [default = -50];
    if The_Message.Has_Default_Sfixed64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Signed_Fixed_64 (The_Coded_Output_Stream, 70, The_Message.Default_Sfixed64);
    end if;
    -- optional float default_float = 71 [default = 51.5];
    if The_Message.Has_Default_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 71, The_Message.Default_Float);
    end if;
    -- optional double default_double = 72 [default = 52000];
    if The_Message.Has_Default_Double then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Double (The_Coded_Output_Stream, 72, The_Message.Default_Double);
    end if;
    -- optional bool default_bool = 73 [default = true];
    if The_Message.Has_Default_Bool then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Boolean (The_Coded_Output_Stream, 73, The_Message.Default_Bool);
    end if;
    -- optional string default_string = 74 [default = "hello"];
    if The_Message.Has_Default_String then
      The_Coded_Output_Stream.Write_String (74, The_Message.Default_String.all);
    end if;
    -- optional bytes default_bytes = 75 [default = "world"];
    if The_Message.Has_Default_Bytes then
      The_Coded_Output_Stream.Write_String (75, The_Message.Default_Bytes.all);
    end if;
    -- optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
    if The_Message.Has_Default_Nested_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 81, Enumeration_To_PB_Int32(The_Message.Default_Nested_Enum));
    end if;
    -- optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
    if The_Message.Has_Default_Foreign_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 82, Enumeration_To_PB_Int32(The_Message.Default_Foreign_Enum));
    end if;
    -- optional .protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
    if The_Message.Has_Default_Import_Enum then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 83, Enumeration_To_PB_Int32(The_Message.Default_Import_Enum));
    end if;
    -- optional string default_string_piece = 84 [default = "abc", ctype = STRING_PIECE];
    if The_Message.Has_Default_String_Piece then
      The_Coded_Output_Stream.Write_String (84, The_Message.Default_String_Piece.all);
    end if;
    -- optional string default_cord = 85 [default = "123", ctype = CORD];
    if The_Message.Has_Default_Cord then
      The_Coded_Output_Stream.Write_String (85, The_Message.Default_Cord.all);
    end if;
  end Serialize_With_Cached_Sizes;

  procedure Merge_Partial_From_Coded_Input_Stream
    (The_Message   : in out Unittest.TestAllTypes.Instance;
     The_Coded_Input_Stream : in out
       Protocol_Buffers.IO.Coded_Input_Stream.Instance) is
    Tag : Protocol_Buffers.Wire_Format.PB_UInt32;
  begin
    Tag := The_Coded_Input_Stream.Read_Tag;
    while Tag /= 0 loop
      case Protocol_Buffers.Wire_Format.Get_Tag_Field_Number (Tag) is
      -- optional int32 optional_int32 = 1;
      when 1 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Int32 := The_Coded_Input_Stream.Read_Integer_32;
          The_Message.Set_Has_Optional_Int32;
        end if;
      -- optional int64 optional_int64 = 2;
      when 2 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Int64 := The_Coded_Input_Stream.Read_Integer_64;
          The_Message.Set_Has_Optional_Int64;
        end if;
      -- optional uint32 optional_uint32 = 3;
      when 3 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Uint32 := The_Coded_Input_Stream.Read_Unsigned_Integer_32;
          The_Message.Set_Has_Optional_Uint32;
        end if;
      -- optional uint64 optional_uint64 = 4;
      when 4 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Uint64 := The_Coded_Input_Stream.Read_Unsigned_Integer_64;
          The_Message.Set_Has_Optional_Uint64;
        end if;
      -- optional sint32 optional_sint32 = 5;
      when 5 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Sint32 := The_Coded_Input_Stream.Read_Signed_Integer_32;
          The_Message.Set_Has_Optional_Sint32;
        end if;
      -- optional sint64 optional_sint64 = 6;
      when 6 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Sint64 := The_Coded_Input_Stream.Read_Signed_Integer_64;
          The_Message.Set_Has_Optional_Sint64;
        end if;
      -- optional fixed32 optional_fixed32 = 7;
      when 7 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Optional_Fixed32 := The_Coded_Input_Stream.Read_Fixed_32;
          The_Message.Set_Has_Optional_Fixed32;
        end if;
      -- optional fixed64 optional_fixed64 = 8;
      when 8 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Optional_Fixed64 := The_Coded_Input_Stream.Read_Fixed_64;
          The_Message.Set_Has_Optional_Fixed64;
        end if;
      -- optional sfixed32 optional_sfixed32 = 9;
      when 9 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Optional_Sfixed32 := The_Coded_Input_Stream.Read_Signed_Fixed_32;
          The_Message.Set_Has_Optional_Sfixed32;
        end if;
      -- optional sfixed64 optional_sfixed64 = 10;
      when 10 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Optional_Sfixed64 := The_Coded_Input_Stream.Read_Signed_Fixed_64;
          The_Message.Set_Has_Optional_Sfixed64;
        end if;
      -- optional float optional_float = 11;
      when 11 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Optional_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Optional_Float;
        end if;
      -- optional double optional_double = 12;
      when 12 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Optional_Double := The_Coded_Input_Stream.Read_Double;
          The_Message.Set_Has_Optional_Double;
        end if;
      -- optional bool optional_bool = 13;
      when 13 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Bool := The_Coded_Input_Stream.Read_Boolean;
          The_Message.Set_Has_Optional_Bool;
        end if;
      -- optional string optional_string = 14;
      when 14 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Optional_String);
            end if;
          end;
          The_Message.Set_Has_Optional_String;
          The_Message.Optional_String := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional bytes optional_bytes = 15;
      when 15 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Optional_Bytes);
            end if;
          end;
          The_Message.Set_Has_Optional_Bytes;
          The_Message.Optional_Bytes := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
      when 18 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Optional_Nested_Message.all);
        end if;
      -- optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;
      when 19 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Optional_Foreign_Message.all);
        end if;
      -- optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;
      when 20 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Optional_Import_Message.all);
        end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
      when 21 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Nested_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Optional_Nested_Enum;
        end if;
      -- optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
      when 22 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Foreign_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Optional_Foreign_Enum;
        end if;
      -- optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;
      when 23 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Optional_Import_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Optional_Import_Enum;
        end if;
      -- optional string optional_string_piece = 24 [ctype = STRING_PIECE];
      when 24 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Optional_String_Piece);
            end if;
          end;
          The_Message.Set_Has_Optional_String_Piece;
          The_Message.Optional_String_Piece := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string optional_cord = 25 [ctype = CORD];
      when 25 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Optional_Cord);
            end if;
          end;
          The_Message.Set_Has_Optional_Cord;
          The_Message.Optional_Cord := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
      when 26 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Optional_Public_Import_Message.all);
        end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27 [lazy = true];
      when 27 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Optional_Lazy_Message.all);
        end if;
      -- repeated int32 repeated_int32 = 31;
      when 31 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Int32.Append (The_Coded_Input_Stream.Read_Integer_32);
        end if;
      -- repeated int64 repeated_int64 = 32;
      when 32 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Int64.Append (The_Coded_Input_Stream.Read_Integer_64);
        end if;
      -- repeated uint32 repeated_uint32 = 33;
      when 33 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Uint32.Append (The_Coded_Input_Stream.Read_Unsigned_Integer_32);
        end if;
      -- repeated uint64 repeated_uint64 = 34;
      when 34 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Uint64.Append (The_Coded_Input_Stream.Read_Unsigned_Integer_64);
        end if;
      -- repeated sint32 repeated_sint32 = 35;
      when 35 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Sint32.Append (The_Coded_Input_Stream.Read_Signed_Integer_32);
        end if;
      -- repeated sint64 repeated_sint64 = 36;
      when 36 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Sint64.Append (The_Coded_Input_Stream.Read_Signed_Integer_64);
        end if;
      -- repeated fixed32 repeated_fixed32 = 37;
      when 37 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Repeated_Fixed32.Append (The_Coded_Input_Stream.Read_Fixed_32);
        end if;
      -- repeated fixed64 repeated_fixed64 = 38;
      when 38 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Repeated_Fixed64.Append (The_Coded_Input_Stream.Read_Fixed_64);
        end if;
      -- repeated sfixed32 repeated_sfixed32 = 39;
      when 39 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Repeated_Sfixed32.Append (The_Coded_Input_Stream.Read_Signed_Fixed_32);
        end if;
      -- repeated sfixed64 repeated_sfixed64 = 40;
      when 40 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Repeated_Sfixed64.Append (The_Coded_Input_Stream.Read_Signed_Fixed_64);
        end if;
      -- repeated float repeated_float = 41;
      when 41 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Repeated_Float.Append (The_Coded_Input_Stream.Read_Float);
        end if;
      -- repeated double repeated_double = 42;
      when 42 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Repeated_Double.Append (The_Coded_Input_Stream.Read_Double);
        end if;
      -- repeated bool repeated_bool = 43;
      when 43 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Bool.Append (The_Coded_Input_Stream.Read_Boolean);
        end if;
      -- repeated string repeated_string = 44;
      when 44 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Message.Repeated_String.Append (The_Coded_Input_Stream.Read_String);
        end if;
      -- repeated bytes repeated_bytes = 45;
      when 45 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Message.Repeated_Bytes.Append (The_Coded_Input_Stream.Read_String);
        end if;
      -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
      when 48 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access := The_Message.Add_Repeated_Nested_Message;
          begin
            The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
      when 49 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            Temp : Unittest.ForeignMessage.ForeignMessage_Access := The_Message.Add_Repeated_Foreign_Message;
          begin
            The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .protobuf_unittest_import.ImportMessage repeated_import_message = 50;
      when 50 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            Temp : Unittest.ImportMessage.ImportMessage_Access := The_Message.Add_Repeated_Import_Message;
          begin
            The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
      when 51 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Nested_Enum.Append (The_Coded_Input_Stream.Read_Enumeration);
        end if;
      -- repeated .protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
      when 52 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Foreign_Enum.Append (The_Coded_Input_Stream.Read_Enumeration);
        end if;
      -- repeated .protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
      when 53 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Repeated_Import_Enum.Append (The_Coded_Input_Stream.Read_Enumeration);
        end if;
      -- repeated string repeated_string_piece = 54 [ctype = STRING_PIECE];
      when 54 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Message.Repeated_String_Piece.Append (The_Coded_Input_Stream.Read_String);
        end if;
      -- repeated string repeated_cord = 55 [ctype = CORD];
      when 55 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          The_Message.Repeated_Cord.Append (The_Coded_Input_Stream.Read_String);
        end if;
      -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57 [lazy = true];
      when 57 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access := The_Message.Add_Repeated_Lazy_Message;
          begin
            The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- optional int32 default_int32 = 61 [default = 41];
      when 61 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Int32 := The_Coded_Input_Stream.Read_Integer_32;
          The_Message.Set_Has_Default_Int32;
        end if;
      -- optional int64 default_int64 = 62 [default = 42];
      when 62 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Int64 := The_Coded_Input_Stream.Read_Integer_64;
          The_Message.Set_Has_Default_Int64;
        end if;
      -- optional uint32 default_uint32 = 63 [default = 43];
      when 63 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Uint32 := The_Coded_Input_Stream.Read_Unsigned_Integer_32;
          The_Message.Set_Has_Default_Uint32;
        end if;
      -- optional uint64 default_uint64 = 64 [default = 44];
      when 64 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Uint64 := The_Coded_Input_Stream.Read_Unsigned_Integer_64;
          The_Message.Set_Has_Default_Uint64;
        end if;
      -- optional sint32 default_sint32 = 65 [default = -45];
      when 65 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Sint32 := The_Coded_Input_Stream.Read_Signed_Integer_32;
          The_Message.Set_Has_Default_Sint32;
        end if;
      -- optional sint64 default_sint64 = 66 [default = 46];
      when 66 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Sint64 := The_Coded_Input_Stream.Read_Signed_Integer_64;
          The_Message.Set_Has_Default_Sint64;
        end if;
      -- optional fixed32 default_fixed32 = 67 [default = 47];
      when 67 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Default_Fixed32 := The_Coded_Input_Stream.Read_Fixed_32;
          The_Message.Set_Has_Default_Fixed32;
        end if;
      -- optional fixed64 default_fixed64 = 68 [default = 48];
      when 68 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Default_Fixed64 := The_Coded_Input_Stream.Read_Fixed_64;
          The_Message.Set_Has_Default_Fixed64;
        end if;
      -- optional sfixed32 default_sfixed32 = 69 [default = 49];
      when 69 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Default_Sfixed32 := The_Coded_Input_Stream.Read_Signed_Fixed_32;
          The_Message.Set_Has_Default_Sfixed32;
        end if;
      -- optional sfixed64 default_sfixed64 = 70 [default = -50];
      when 70 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Default_Sfixed64 := The_Coded_Input_Stream.Read_Signed_Fixed_64;
          The_Message.Set_Has_Default_Sfixed64;
        end if;
      -- optional float default_float = 71 [default = 51.5];
      when 71 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Default_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Default_Float;
        end if;
      -- optional double default_double = 72 [default = 52000];
      when 72 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Default_Double := The_Coded_Input_Stream.Read_Double;
          The_Message.Set_Has_Default_Double;
        end if;
      -- optional bool default_bool = 73 [default = true];
      when 73 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Bool := The_Coded_Input_Stream.Read_Boolean;
          The_Message.Set_Has_Default_Bool;
        end if;
      -- optional string default_string = 74 [default = "hello"];
      when 74 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Default_String /= Default_Default_String'Access then
              Free (The_Message.Default_String);
            end if;
          end;
          The_Message.Set_Has_Default_String;
          The_Message.Default_String := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional bytes default_bytes = 75 [default = "world"];
      when 75 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
              Free (The_Message.Default_Bytes);
            end if;
          end;
          The_Message.Set_Has_Default_Bytes;
          The_Message.Default_Bytes := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
      when 81 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Nested_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Default_Nested_Enum;
        end if;
      -- optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
      when 82 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Foreign_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Default_Foreign_Enum;
        end if;
      -- optional .protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
      when 83 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Default_Import_Enum := PB_Int32_To_Enumeration(The_Coded_Input_Stream.Read_Integer_32);
          The_Message.Set_Has_Default_Import_Enum;
        end if;
      -- optional string default_string_piece = 84 [default = "abc", ctype = STRING_PIECE];
      when 84 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
              Free (The_Message.Default_String_Piece);
            end if;
          end;
          The_Message.Set_Has_Default_String_Piece;
          The_Message.Default_String_Piece := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string default_cord = 85 [default = "123", ctype = CORD];
      when 85 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Default_Cord /= Default_Default_Cord'Access then
              Free (The_Message.Default_Cord);
            end if;
          end;
          The_Message.Set_Has_Default_Cord;
          The_Message.Default_Cord := The_Coded_Input_Stream.Read_String;
        end if;
      when others =>
        declare
          Dummy : Protocol_Buffers.Wire_Format.PB_Bool;
          pragma Unreferenced (Dummy);
        begin
          Dummy := The_Coded_Input_Stream.Skip_Field (Tag);
          return;
        end;
      end case;
      Tag := The_Coded_Input_Stream.Read_Tag;
    end loop;
  end Merge_Partial_From_Coded_Input_Stream;

  function Get_Cached_Size
    (The_Message : in Unittest.TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return The_Message.Cached_Size;
  end Get_Cached_Size;

  overriding
  procedure Finalize
    (The_Message : in out Unittest.TestAllTypes.Instance) is
  begin
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_String);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_Bytes);
      end if;
    end;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Nested_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Nested_Message := null;
    end;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Foreign_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Foreign_Message := null;
    end;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Import_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Import_Message := null;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_String_Piece);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_Cord);
      end if;
    end;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Public_Import_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Public_Import_Message := null;
    end;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Lazy_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Lazy_Message := null;
    end;
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String.Clear;

    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Bytes loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Bytes.Clear;

    for C in The_Message.Repeated_Nested_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Nested_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Nested_Message.Clear;

    for C in The_Message.Repeated_Foreign_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Foreign_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Foreign_Message.Clear;

    for C in The_Message.Repeated_Import_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Import_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Import_Message.Clear;

    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String_Piece loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String_Piece.Clear;

    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Cord loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Cord.Clear;

    for C in The_Message.Repeated_Lazy_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Lazy_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Lazy_Message.Clear;

    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_String /= Default_Default_String'Access then
        Free (The_Message.Default_String);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
        Free (The_Message.Default_Bytes);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
        Free (The_Message.Default_String_Piece);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_Cord /= Default_Default_Cord'Access then
        Free (The_Message.Default_Cord);
      end if;
    end;
  end Finalize;

  ---------------------------------------------------------------------------
  -- Field accessor definitions ---------------------------------------------
  ---------------------------------------------------------------------------

  -- optional int32 optional_int32 = 1;
  function Has_Optional_Int32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000001#) /= 0;
  end Has_Optional_Int32;

  procedure Set_Has_Optional_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000001#;
  end Set_Has_Optional_Int32;

  procedure Clear_Has_Optional_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000001#);
  end Clear_Has_Optional_Int32;

  procedure Clear_Optional_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Int32 := 0;
    The_Message.Clear_Has_Optional_Int32;
  end Clear_Optional_Int32;

  function Get_Optional_Int32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Optional_Int32;
  end Get_Optional_Int32;

  procedure Set_Optional_Int32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Optional_Int32;
    The_Message.Optional_Int32 := Value;
  end Set_Optional_Int32;

  -- optional int64 optional_int64 = 2;
  function Has_Optional_Int64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000002#) /= 0;
  end Has_Optional_Int64;

  procedure Set_Has_Optional_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000002#;
  end Set_Has_Optional_Int64;

  procedure Clear_Has_Optional_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000002#);
  end Clear_Has_Optional_Int64;

  procedure Clear_Optional_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Int64 := 0;
    The_Message.Clear_Has_Optional_Int64;
  end Clear_Optional_Int64;

  function Get_Optional_Int64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Optional_Int64;
  end Get_Optional_Int64;

  procedure Set_Optional_Int64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Optional_Int64;
    The_Message.Optional_Int64 := Value;
  end Set_Optional_Int64;

  -- optional uint32 optional_uint32 = 3;
  function Has_Optional_Uint32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000004#) /= 0;
  end Has_Optional_Uint32;

  procedure Set_Has_Optional_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000004#;
  end Set_Has_Optional_Uint32;

  procedure Clear_Has_Optional_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000004#);
  end Clear_Has_Optional_Uint32;

  procedure Clear_Optional_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Uint32 := 0;
    The_Message.Clear_Has_Optional_Uint32;
  end Clear_Optional_Uint32;

  function Get_Optional_Uint32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Optional_Uint32;
  end Get_Optional_Uint32;

  procedure Set_Optional_Uint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Set_Has_Optional_Uint32;
    The_Message.Optional_Uint32 := Value;
  end Set_Optional_Uint32;

  -- optional uint64 optional_uint64 = 4;
  function Has_Optional_Uint64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000008#) /= 0;
  end Has_Optional_Uint64;

  procedure Set_Has_Optional_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000008#;
  end Set_Has_Optional_Uint64;

  procedure Clear_Has_Optional_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000008#);
  end Clear_Has_Optional_Uint64;

  procedure Clear_Optional_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Uint64 := 0;
    The_Message.Clear_Has_Optional_Uint64;
  end Clear_Optional_Uint64;

  function Get_Optional_Uint64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Optional_Uint64;
  end Get_Optional_Uint64;

  procedure Set_Optional_Uint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Set_Has_Optional_Uint64;
    The_Message.Optional_Uint64 := Value;
  end Set_Optional_Uint64;

  -- optional sint32 optional_sint32 = 5;
  function Has_Optional_Sint32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000010#) /= 0;
  end Has_Optional_Sint32;

  procedure Set_Has_Optional_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000010#;
  end Set_Has_Optional_Sint32;

  procedure Clear_Has_Optional_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000010#);
  end Clear_Has_Optional_Sint32;

  procedure Clear_Optional_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Sint32 := 0;
    The_Message.Clear_Has_Optional_Sint32;
  end Clear_Optional_Sint32;

  function Get_Optional_Sint32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Optional_Sint32;
  end Get_Optional_Sint32;

  procedure Set_Optional_Sint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Optional_Sint32;
    The_Message.Optional_Sint32 := Value;
  end Set_Optional_Sint32;

  -- optional sint64 optional_sint64 = 6;
  function Has_Optional_Sint64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000020#) /= 0;
  end Has_Optional_Sint64;

  procedure Set_Has_Optional_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000020#;
  end Set_Has_Optional_Sint64;

  procedure Clear_Has_Optional_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000020#);
  end Clear_Has_Optional_Sint64;

  procedure Clear_Optional_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Sint64 := 0;
    The_Message.Clear_Has_Optional_Sint64;
  end Clear_Optional_Sint64;

  function Get_Optional_Sint64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Optional_Sint64;
  end Get_Optional_Sint64;

  procedure Set_Optional_Sint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Optional_Sint64;
    The_Message.Optional_Sint64 := Value;
  end Set_Optional_Sint64;

  -- optional fixed32 optional_fixed32 = 7;
  function Has_Optional_Fixed32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000040#) /= 0;
  end Has_Optional_Fixed32;

  procedure Set_Has_Optional_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000040#;
  end Set_Has_Optional_Fixed32;

  procedure Clear_Has_Optional_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000040#);
  end Clear_Has_Optional_Fixed32;

  procedure Clear_Optional_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Fixed32 := 0;
    The_Message.Clear_Has_Optional_Fixed32;
  end Clear_Optional_Fixed32;

  function Get_Optional_Fixed32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Optional_Fixed32;
  end Get_Optional_Fixed32;

  procedure Set_Optional_Fixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Set_Has_Optional_Fixed32;
    The_Message.Optional_Fixed32 := Value;
  end Set_Optional_Fixed32;

  -- optional fixed64 optional_fixed64 = 8;
  function Has_Optional_Fixed64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000080#) /= 0;
  end Has_Optional_Fixed64;

  procedure Set_Has_Optional_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000080#;
  end Set_Has_Optional_Fixed64;

  procedure Clear_Has_Optional_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000080#);
  end Clear_Has_Optional_Fixed64;

  procedure Clear_Optional_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Fixed64 := 0;
    The_Message.Clear_Has_Optional_Fixed64;
  end Clear_Optional_Fixed64;

  function Get_Optional_Fixed64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Optional_Fixed64;
  end Get_Optional_Fixed64;

  procedure Set_Optional_Fixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Set_Has_Optional_Fixed64;
    The_Message.Optional_Fixed64 := Value;
  end Set_Optional_Fixed64;

  -- optional sfixed32 optional_sfixed32 = 9;
  function Has_Optional_Sfixed32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000100#) /= 0;
  end Has_Optional_Sfixed32;

  procedure Set_Has_Optional_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000100#;
  end Set_Has_Optional_Sfixed32;

  procedure Clear_Has_Optional_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000100#);
  end Clear_Has_Optional_Sfixed32;

  procedure Clear_Optional_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Sfixed32 := 0;
    The_Message.Clear_Has_Optional_Sfixed32;
  end Clear_Optional_Sfixed32;

  function Get_Optional_Sfixed32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Optional_Sfixed32;
  end Get_Optional_Sfixed32;

  procedure Set_Optional_Sfixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Optional_Sfixed32;
    The_Message.Optional_Sfixed32 := Value;
  end Set_Optional_Sfixed32;

  -- optional sfixed64 optional_sfixed64 = 10;
  function Has_Optional_Sfixed64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000200#) /= 0;
  end Has_Optional_Sfixed64;

  procedure Set_Has_Optional_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000200#;
  end Set_Has_Optional_Sfixed64;

  procedure Clear_Has_Optional_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000200#);
  end Clear_Has_Optional_Sfixed64;

  procedure Clear_Optional_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Sfixed64 := 0;
    The_Message.Clear_Has_Optional_Sfixed64;
  end Clear_Optional_Sfixed64;

  function Get_Optional_Sfixed64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Optional_Sfixed64;
  end Get_Optional_Sfixed64;

  procedure Set_Optional_Sfixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Optional_Sfixed64;
    The_Message.Optional_Sfixed64 := Value;
  end Set_Optional_Sfixed64;

  -- optional float optional_float = 11;
  function Has_Optional_Float
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000400#) /= 0;
  end Has_Optional_Float;

  procedure Set_Has_Optional_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000400#;
  end Set_Has_Optional_Float;

  procedure Clear_Has_Optional_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000400#);
  end Clear_Has_Optional_Float;

  procedure Clear_Optional_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
    The_Message.Clear_Has_Optional_Float;
  end Clear_Optional_Float;

  function Get_Optional_Float
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Optional_Float;
  end Get_Optional_Float;

  procedure Set_Optional_Float
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Optional_Float;
    The_Message.Optional_Float := Value;
  end Set_Optional_Float;

  -- optional double optional_double = 12;
  function Has_Optional_Double
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000800#) /= 0;
  end Has_Optional_Double;

  procedure Set_Has_Optional_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000800#;
  end Set_Has_Optional_Double;

  procedure Clear_Has_Optional_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000800#);
  end Clear_Has_Optional_Double;

  procedure Clear_Optional_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Double := Protocol_Buffers.Wire_Format.PB_Double (0.00000000000000);
    The_Message.Clear_Has_Optional_Double;
  end Clear_Optional_Double;

  function Get_Optional_Double
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Optional_Double;
  end Get_Optional_Double;

  procedure Set_Optional_Double
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Set_Has_Optional_Double;
    The_Message.Optional_Double := Value;
  end Set_Optional_Double;

  -- optional bool optional_bool = 13;
  function Has_Optional_Bool
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00001000#) /= 0;
  end Has_Optional_Bool;

  procedure Set_Has_Optional_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00001000#;
  end Set_Has_Optional_Bool;

  procedure Clear_Has_Optional_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00001000#);
  end Clear_Has_Optional_Bool;

  procedure Clear_Optional_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Bool := False;
    The_Message.Clear_Has_Optional_Bool;
  end Clear_Optional_Bool;

  function Get_Optional_Bool
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Bool is
  begin
    return The_Message.Optional_Bool;
  end Get_Optional_Bool;

  procedure Set_Optional_Bool
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Bool) is
  begin
    The_Message.Set_Has_Optional_Bool;
    The_Message.Optional_Bool := Value;
  end Set_Optional_Bool;

  -- optional string optional_string = 14;
  function Has_Optional_String
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00002000#) /= 0;
  end Has_Optional_String;

  procedure Set_Has_Optional_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00002000#;
  end Set_Has_Optional_String;

  procedure Clear_Has_Optional_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00002000#);
  end Clear_Has_Optional_String;

  procedure Clear_Optional_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_String;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_String);
      end if;
    end;
    The_Message.Optional_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Optional_String;
  end Clear_Optional_String;

  function Get_Optional_String
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Optional_String.all;
  end Get_Optional_String;

  function Get_Optional_String
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Optional_String;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_String);
        end if;
      end;
      The_Message.Optional_String := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Optional_String;
    end if;

    if The_Message.Optional_String = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      The_Message.Optional_String := new String'(Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING);
    end if;
    return The_Message.Optional_String;
  end Get_Optional_String;

  procedure Set_Optional_String
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Optional_String;
    if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Optional_String.all'Length then
      The_Message.Optional_String.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_String);
        end if;
      end;
      The_Message.Optional_String := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Optional_String;

  function Release_Optional_String
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Optional_String;
    if The_Message.Optional_String = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Optional_String;
      begin
        The_Message.Optional_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
        return Temp;
      end;
    end if;
  end Release_Optional_String;

  -- optional bytes optional_bytes = 15;
  function Has_Optional_Bytes
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00004000#) /= 0;
  end Has_Optional_Bytes;

  procedure Set_Has_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00004000#;
  end Set_Has_Optional_Bytes;

  procedure Clear_Has_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00004000#);
  end Clear_Has_Optional_Bytes;

  procedure Clear_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Bytes;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_Bytes);
      end if;
    end;
    The_Message.Optional_Bytes := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Optional_Bytes;
  end Clear_Optional_Bytes;

  function Get_Optional_Bytes
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Optional_Bytes.all;
  end Get_Optional_Bytes;

  function Get_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Optional_Bytes;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_Bytes);
        end if;
      end;
      The_Message.Optional_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Optional_Bytes;
    end if;

    if The_Message.Optional_Bytes = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      The_Message.Optional_Bytes := new String'(Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING);
    end if;
    return The_Message.Optional_Bytes;
  end Get_Optional_Bytes;

  procedure Set_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Optional_Bytes;
    if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Optional_Bytes.all'Length then
      The_Message.Optional_Bytes.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_Bytes /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_Bytes);
        end if;
      end;
      The_Message.Optional_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Optional_Bytes;

  function Release_Optional_Bytes
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Optional_Bytes;
    if The_Message.Optional_Bytes = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Optional_Bytes;
      begin
        The_Message.Optional_Bytes := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
        return Temp;
      end;
    end if;
  end Release_Optional_Bytes;

  -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_nested_message = 18;
  function Has_Optional_Nested_Message
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00008000#) /= 0;
  end Has_Optional_Nested_Message;

  procedure Set_Has_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00008000#;
  end Set_Has_Optional_Nested_Message;

  procedure Clear_Has_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00008000#);
  end Clear_Has_Optional_Nested_Message;

  procedure Clear_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Nested_Message;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Nested_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Nested_Message := null;
    end;
    The_Message.Clear_Has_Optional_Nested_Message;
  end Clear_Optional_Nested_Message;

  function Get_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    use type Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
  begin
    The_Message.Set_Has_Optional_Nested_Message;
    if The_Message.Optional_Nested_Message = null then
      The_Message.Optional_Nested_Message := Unittest.TestAllTypes.NestedMessage.NestedMessage_Access'(new Unittest.TestAllTypes.NestedMessage.Instance);
    end if;
    return The_Message.Optional_Nested_Message;
  end Get_Optional_Nested_Message;

  function Release_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    Temp : access Unittest.TestAllTypes.NestedMessage.Instance;
  begin
    The_Message.Clear_Has_Optional_Nested_Message;
    Temp := The_Message.Optional_Nested_Message;
    The_Message.Optional_Nested_Message := null;
    return Temp;
  end Release_Optional_Nested_Message;

  procedure Set_Optional_Nested_Message
    (The_Message : in out TestAllTypes.Instance;
     Value : in Unittest.TestAllTypes.NestedMessage.NestedMessage_Access) is
    use type Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
    Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access (The_Message.Optional_Nested_Message);
  begin
    Protocol_Buffers.Message.Free (Temp);
    The_Message.Optional_Nested_Message := Value;
    if The_Message.Optional_Nested_Message /= null then
      The_Message.Set_Has_Optional_Nested_Message;
    else
      The_Message.Clear_Has_Optional_Nested_Message;
    end if;
  end Set_Optional_Nested_Message;

  -- optional .protobuf_unittest.ForeignMessage optional_foreign_message = 19;
  function Has_Optional_Foreign_Message
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00010000#) /= 0;
  end Has_Optional_Foreign_Message;

  procedure Set_Has_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00010000#;
  end Set_Has_Optional_Foreign_Message;

  procedure Clear_Has_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00010000#);
  end Clear_Has_Optional_Foreign_Message;

  procedure Clear_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Foreign_Message;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Foreign_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Foreign_Message := null;
    end;
    The_Message.Clear_Has_Optional_Foreign_Message;
  end Clear_Optional_Foreign_Message;

  function Get_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ForeignMessage.Instance is
    use type Unittest.ForeignMessage.ForeignMessage_Access;
  begin
    The_Message.Set_Has_Optional_Foreign_Message;
    if The_Message.Optional_Foreign_Message = null then
      The_Message.Optional_Foreign_Message := Unittest.ForeignMessage.ForeignMessage_Access'(new Unittest.ForeignMessage.Instance);
    end if;
    return The_Message.Optional_Foreign_Message;
  end Get_Optional_Foreign_Message;

  function Release_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ForeignMessage.Instance is
    Temp : access Unittest.ForeignMessage.Instance;
  begin
    The_Message.Clear_Has_Optional_Foreign_Message;
    Temp := The_Message.Optional_Foreign_Message;
    The_Message.Optional_Foreign_Message := null;
    return Temp;
  end Release_Optional_Foreign_Message;

  procedure Set_Optional_Foreign_Message
    (The_Message : in out TestAllTypes.Instance;
     Value : in Unittest.ForeignMessage.ForeignMessage_Access) is
    use type Unittest.ForeignMessage.ForeignMessage_Access;
    Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access (The_Message.Optional_Foreign_Message);
  begin
    Protocol_Buffers.Message.Free (Temp);
    The_Message.Optional_Foreign_Message := Value;
    if The_Message.Optional_Foreign_Message /= null then
      The_Message.Set_Has_Optional_Foreign_Message;
    else
      The_Message.Clear_Has_Optional_Foreign_Message;
    end if;
  end Set_Optional_Foreign_Message;

  -- optional .protobuf_unittest_import.ImportMessage optional_import_message = 20;
  function Has_Optional_Import_Message
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00020000#) /= 0;
  end Has_Optional_Import_Message;

  procedure Set_Has_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00020000#;
  end Set_Has_Optional_Import_Message;

  procedure Clear_Has_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00020000#);
  end Clear_Has_Optional_Import_Message;

  procedure Clear_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Import_Message;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Import_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Import_Message := null;
    end;
    The_Message.Clear_Has_Optional_Import_Message;
  end Clear_Optional_Import_Message;

  function Get_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ImportMessage.Instance is
    use type Unittest.ImportMessage.ImportMessage_Access;
  begin
    The_Message.Set_Has_Optional_Import_Message;
    if The_Message.Optional_Import_Message = null then
      The_Message.Optional_Import_Message := Unittest.ImportMessage.ImportMessage_Access'(new Unittest.ImportMessage.Instance);
    end if;
    return The_Message.Optional_Import_Message;
  end Get_Optional_Import_Message;

  function Release_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ImportMessage.Instance is
    Temp : access Unittest.ImportMessage.Instance;
  begin
    The_Message.Clear_Has_Optional_Import_Message;
    Temp := The_Message.Optional_Import_Message;
    The_Message.Optional_Import_Message := null;
    return Temp;
  end Release_Optional_Import_Message;

  procedure Set_Optional_Import_Message
    (The_Message : in out TestAllTypes.Instance;
     Value : in Unittest.ImportMessage.ImportMessage_Access) is
    use type Unittest.ImportMessage.ImportMessage_Access;
    Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access (The_Message.Optional_Import_Message);
  begin
    Protocol_Buffers.Message.Free (Temp);
    The_Message.Optional_Import_Message := Value;
    if The_Message.Optional_Import_Message /= null then
      The_Message.Set_Has_Optional_Import_Message;
    else
      The_Message.Clear_Has_Optional_Import_Message;
    end if;
  end Set_Optional_Import_Message;

  -- optional .protobuf_unittest.TestAllTypes.NestedEnum optional_nested_enum = 21;
  function Has_Optional_Nested_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00040000#) /= 0;
  end Has_Optional_Nested_Enum;

  procedure Set_Has_Optional_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00040000#;
  end Set_Has_Optional_Nested_Enum;

  procedure Clear_Has_Optional_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00040000#);
  end Clear_Has_Optional_Nested_Enum;

  procedure Clear_Optional_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Nested_Enum := NestedEnum'(FOO);
    The_Message.Clear_Has_Optional_Nested_Enum;
  end Clear_Optional_Nested_Enum;

  function Get_Optional_Nested_Enum
    (The_Message : in TestAllTypes.Instance) return NestedEnum is
  begin
    return The_Message.Optional_Nested_Enum;
  end Get_Optional_Nested_Enum;

  procedure Set_Optional_Nested_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in NestedEnum) is
  begin
    Set_Has_Optional_Nested_Enum (The_Message);
    The_Message.Optional_Nested_Enum := Value;
  end Set_Optional_Nested_Enum;

  -- optional .protobuf_unittest.ForeignEnum optional_foreign_enum = 22;
  function Has_Optional_Foreign_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00080000#) /= 0;
  end Has_Optional_Foreign_Enum;

  procedure Set_Has_Optional_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00080000#;
  end Set_Has_Optional_Foreign_Enum;

  procedure Clear_Has_Optional_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00080000#);
  end Clear_Has_Optional_Foreign_Enum;

  procedure Clear_Optional_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Foreign_Enum := ForeignEnum'(FOREIGN_FOO);
    The_Message.Clear_Has_Optional_Foreign_Enum;
  end Clear_Optional_Foreign_Enum;

  function Get_Optional_Foreign_Enum
    (The_Message : in TestAllTypes.Instance) return ForeignEnum is
  begin
    return The_Message.Optional_Foreign_Enum;
  end Get_Optional_Foreign_Enum;

  procedure Set_Optional_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ForeignEnum) is
  begin
    Set_Has_Optional_Foreign_Enum (The_Message);
    The_Message.Optional_Foreign_Enum := Value;
  end Set_Optional_Foreign_Enum;

  -- optional .protobuf_unittest_import.ImportEnum optional_import_enum = 23;
  function Has_Optional_Import_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00100000#) /= 0;
  end Has_Optional_Import_Enum;

  procedure Set_Has_Optional_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00100000#;
  end Set_Has_Optional_Import_Enum;

  procedure Clear_Has_Optional_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00100000#);
  end Clear_Has_Optional_Import_Enum;

  procedure Clear_Optional_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Optional_Import_Enum := ImportEnum'(IMPORT_FOO);
    The_Message.Clear_Has_Optional_Import_Enum;
  end Clear_Optional_Import_Enum;

  function Get_Optional_Import_Enum
    (The_Message : in TestAllTypes.Instance) return ImportEnum is
  begin
    return The_Message.Optional_Import_Enum;
  end Get_Optional_Import_Enum;

  procedure Set_Optional_Import_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ImportEnum) is
  begin
    Set_Has_Optional_Import_Enum (The_Message);
    The_Message.Optional_Import_Enum := Value;
  end Set_Optional_Import_Enum;

  -- optional string optional_string_piece = 24 [ctype = STRING_PIECE];
  function Has_Optional_String_Piece
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00200000#) /= 0;
  end Has_Optional_String_Piece;

  procedure Set_Has_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00200000#;
  end Set_Has_Optional_String_Piece;

  procedure Clear_Has_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00200000#);
  end Clear_Has_Optional_String_Piece;

  procedure Clear_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_String_Piece;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_String_Piece);
      end if;
    end;
    The_Message.Optional_String_Piece := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Optional_String_Piece;
  end Clear_Optional_String_Piece;

  function Get_Optional_String_Piece
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Optional_String_Piece.all;
  end Get_Optional_String_Piece;

  function Get_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Optional_String_Piece;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_String_Piece);
        end if;
      end;
      The_Message.Optional_String_Piece := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Optional_String_Piece;
    end if;

    if The_Message.Optional_String_Piece = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      The_Message.Optional_String_Piece := new String'(Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING);
    end if;
    return The_Message.Optional_String_Piece;
  end Get_Optional_String_Piece;

  procedure Set_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Optional_String_Piece;
    if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Optional_String_Piece.all'Length then
      The_Message.Optional_String_Piece.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_String_Piece /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_String_Piece);
        end if;
      end;
      The_Message.Optional_String_Piece := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Optional_String_Piece;

  function Release_Optional_String_Piece
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Optional_String_Piece;
    if The_Message.Optional_String_Piece = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Optional_String_Piece;
      begin
        The_Message.Optional_String_Piece := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
        return Temp;
      end;
    end if;
  end Release_Optional_String_Piece;

  -- optional string optional_cord = 25 [ctype = CORD];
  function Has_Optional_Cord
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00400000#) /= 0;
  end Has_Optional_Cord;

  procedure Set_Has_Optional_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00400000#;
  end Set_Has_Optional_Cord;

  procedure Clear_Has_Optional_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00400000#);
  end Clear_Has_Optional_Cord;

  procedure Clear_Optional_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Cord;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Optional_Cord);
      end if;
    end;
    The_Message.Optional_Cord := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Optional_Cord;
  end Clear_Optional_Cord;

  function Get_Optional_Cord
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Optional_Cord.all;
  end Get_Optional_Cord;

  function Get_Optional_Cord
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Optional_Cord;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_Cord);
        end if;
      end;
      The_Message.Optional_Cord := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Optional_Cord;
    end if;

    if The_Message.Optional_Cord = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      The_Message.Optional_Cord := new String'(Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING);
    end if;
    return The_Message.Optional_Cord;
  end Get_Optional_Cord;

  procedure Set_Optional_Cord
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Optional_Cord;
    if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Optional_Cord.all'Length then
      The_Message.Optional_Cord.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Optional_Cord /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Optional_Cord);
        end if;
      end;
      The_Message.Optional_Cord := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Optional_Cord;

  function Release_Optional_Cord
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Optional_Cord;
    if The_Message.Optional_Cord = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Optional_Cord;
      begin
        The_Message.Optional_Cord := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
        return Temp;
      end;
    end if;
  end Release_Optional_Cord;

  -- optional .protobuf_unittest_import.PublicImportMessage optional_public_import_message = 26;
  function Has_Optional_Public_Import_Message
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00800000#) /= 0;
  end Has_Optional_Public_Import_Message;

  procedure Set_Has_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00800000#;
  end Set_Has_Optional_Public_Import_Message;

  procedure Clear_Has_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00800000#);
  end Clear_Has_Optional_Public_Import_Message;

  procedure Clear_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Public_Import_Message;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Public_Import_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Public_Import_Message := null;
    end;
    The_Message.Clear_Has_Optional_Public_Import_Message;
  end Clear_Optional_Public_Import_Message;

  function Get_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.PublicImportMessage.Instance is
    use type Unittest.PublicImportMessage.PublicImportMessage_Access;
  begin
    The_Message.Set_Has_Optional_Public_Import_Message;
    if The_Message.Optional_Public_Import_Message = null then
      The_Message.Optional_Public_Import_Message := Unittest.PublicImportMessage.PublicImportMessage_Access'(new Unittest.PublicImportMessage.Instance);
    end if;
    return The_Message.Optional_Public_Import_Message;
  end Get_Optional_Public_Import_Message;

  function Release_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.PublicImportMessage.Instance is
    Temp : access Unittest.PublicImportMessage.Instance;
  begin
    The_Message.Clear_Has_Optional_Public_Import_Message;
    Temp := The_Message.Optional_Public_Import_Message;
    The_Message.Optional_Public_Import_Message := null;
    return Temp;
  end Release_Optional_Public_Import_Message;

  procedure Set_Optional_Public_Import_Message
    (The_Message : in out TestAllTypes.Instance;
     Value : in Unittest.PublicImportMessage.PublicImportMessage_Access) is
    use type Unittest.PublicImportMessage.PublicImportMessage_Access;
    Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access (The_Message.Optional_Public_Import_Message);
  begin
    Protocol_Buffers.Message.Free (Temp);
    The_Message.Optional_Public_Import_Message := Value;
    if The_Message.Optional_Public_Import_Message /= null then
      The_Message.Set_Has_Optional_Public_Import_Message;
    else
      The_Message.Clear_Has_Optional_Public_Import_Message;
    end if;
  end Set_Optional_Public_Import_Message;

  -- optional .protobuf_unittest.TestAllTypes.NestedMessage optional_lazy_message = 27 [lazy = true];
  function Has_Optional_Lazy_Message
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#01000000#) /= 0;
  end Has_Optional_Lazy_Message;

  procedure Set_Has_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#01000000#;
  end Set_Has_Optional_Lazy_Message;

  procedure Clear_Has_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#01000000#);
  end Clear_Has_Optional_Lazy_Message;

  procedure Clear_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Optional_Lazy_Message;
    declare
      Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access(The_Message.Optional_Lazy_Message);
    begin
      Protocol_Buffers.Message.Free (Temp);
      The_Message.Optional_Lazy_Message := null;
    end;
    The_Message.Clear_Has_Optional_Lazy_Message;
  end Clear_Optional_Lazy_Message;

  function Get_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    use type Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
  begin
    The_Message.Set_Has_Optional_Lazy_Message;
    if The_Message.Optional_Lazy_Message = null then
      The_Message.Optional_Lazy_Message := Unittest.TestAllTypes.NestedMessage.NestedMessage_Access'(new Unittest.TestAllTypes.NestedMessage.Instance);
    end if;
    return The_Message.Optional_Lazy_Message;
  end Get_Optional_Lazy_Message;

  function Release_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    Temp : access Unittest.TestAllTypes.NestedMessage.Instance;
  begin
    The_Message.Clear_Has_Optional_Lazy_Message;
    Temp := The_Message.Optional_Lazy_Message;
    The_Message.Optional_Lazy_Message := null;
    return Temp;
  end Release_Optional_Lazy_Message;

  procedure Set_Optional_Lazy_Message
    (The_Message : in out TestAllTypes.Instance;
     Value : in Unittest.TestAllTypes.NestedMessage.NestedMessage_Access) is
    use type Unittest.TestAllTypes.NestedMessage.NestedMessage_Access;
    Temp : Protocol_Buffers.Message.Instance_Access := Protocol_Buffers.Message.Instance_Access (The_Message.Optional_Lazy_Message);
  begin
    Protocol_Buffers.Message.Free (Temp);
    The_Message.Optional_Lazy_Message := Value;
    if The_Message.Optional_Lazy_Message /= null then
      The_Message.Set_Has_Optional_Lazy_Message;
    else
      The_Message.Clear_Has_Optional_Lazy_Message;
    end if;
  end Set_Optional_Lazy_Message;

  -- repeated int32 repeated_int32 = 31;
  function Repeated_Int32_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Int32.Length);
  end Repeated_Int32_Size;

  procedure Clear_Repeated_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Int32.Clear;
  end Clear_Repeated_Int32;

  function Get_Repeated_Int32
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Repeated_Int32.Element (Index);
  end Get_Repeated_Int32;

  procedure Set_Repeated_Int32
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Int32.Replace_Element (Index, Value);
  end Set_Repeated_Int32;

  procedure Add_Repeated_Int32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Int32.Append (Value);
  end Add_Repeated_Int32;

  -- repeated int64 repeated_int64 = 32;
  function Repeated_Int64_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Int64.Length);
  end Repeated_Int64_Size;

  procedure Clear_Repeated_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Int64.Clear;
  end Clear_Repeated_Int64;

  function Get_Repeated_Int64
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Repeated_Int64.Element (Index);
  end Get_Repeated_Int64;

  procedure Set_Repeated_Int64
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Int64.Replace_Element (Index, Value);
  end Set_Repeated_Int64;

  procedure Add_Repeated_Int64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Int64.Append (Value);
  end Add_Repeated_Int64;

  -- repeated uint32 repeated_uint32 = 33;
  function Repeated_Uint32_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Uint32.Length);
  end Repeated_Uint32_Size;

  procedure Clear_Repeated_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Uint32.Clear;
  end Clear_Repeated_Uint32;

  function Get_Repeated_Uint32
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Repeated_Uint32.Element (Index);
  end Get_Repeated_Uint32;

  procedure Set_Repeated_Uint32
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Repeated_Uint32.Replace_Element (Index, Value);
  end Set_Repeated_Uint32;

  procedure Add_Repeated_Uint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Repeated_Uint32.Append (Value);
  end Add_Repeated_Uint32;

  -- repeated uint64 repeated_uint64 = 34;
  function Repeated_Uint64_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Uint64.Length);
  end Repeated_Uint64_Size;

  procedure Clear_Repeated_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Uint64.Clear;
  end Clear_Repeated_Uint64;

  function Get_Repeated_Uint64
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Repeated_Uint64.Element (Index);
  end Get_Repeated_Uint64;

  procedure Set_Repeated_Uint64
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Repeated_Uint64.Replace_Element (Index, Value);
  end Set_Repeated_Uint64;

  procedure Add_Repeated_Uint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Repeated_Uint64.Append (Value);
  end Add_Repeated_Uint64;

  -- repeated sint32 repeated_sint32 = 35;
  function Repeated_Sint32_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Sint32.Length);
  end Repeated_Sint32_Size;

  procedure Clear_Repeated_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Sint32.Clear;
  end Clear_Repeated_Sint32;

  function Get_Repeated_Sint32
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Repeated_Sint32.Element (Index);
  end Get_Repeated_Sint32;

  procedure Set_Repeated_Sint32
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Sint32.Replace_Element (Index, Value);
  end Set_Repeated_Sint32;

  procedure Add_Repeated_Sint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Sint32.Append (Value);
  end Add_Repeated_Sint32;

  -- repeated sint64 repeated_sint64 = 36;
  function Repeated_Sint64_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Sint64.Length);
  end Repeated_Sint64_Size;

  procedure Clear_Repeated_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Sint64.Clear;
  end Clear_Repeated_Sint64;

  function Get_Repeated_Sint64
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Repeated_Sint64.Element (Index);
  end Get_Repeated_Sint64;

  procedure Set_Repeated_Sint64
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Sint64.Replace_Element (Index, Value);
  end Set_Repeated_Sint64;

  procedure Add_Repeated_Sint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Sint64.Append (Value);
  end Add_Repeated_Sint64;

  -- repeated fixed32 repeated_fixed32 = 37;
  function Repeated_Fixed32_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Fixed32.Length);
  end Repeated_Fixed32_Size;

  procedure Clear_Repeated_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Fixed32.Clear;
  end Clear_Repeated_Fixed32;

  function Get_Repeated_Fixed32
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Repeated_Fixed32.Element (Index);
  end Get_Repeated_Fixed32;

  procedure Set_Repeated_Fixed32
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Repeated_Fixed32.Replace_Element (Index, Value);
  end Set_Repeated_Fixed32;

  procedure Add_Repeated_Fixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Repeated_Fixed32.Append (Value);
  end Add_Repeated_Fixed32;

  -- repeated fixed64 repeated_fixed64 = 38;
  function Repeated_Fixed64_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Fixed64.Length);
  end Repeated_Fixed64_Size;

  procedure Clear_Repeated_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Fixed64.Clear;
  end Clear_Repeated_Fixed64;

  function Get_Repeated_Fixed64
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Repeated_Fixed64.Element (Index);
  end Get_Repeated_Fixed64;

  procedure Set_Repeated_Fixed64
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Repeated_Fixed64.Replace_Element (Index, Value);
  end Set_Repeated_Fixed64;

  procedure Add_Repeated_Fixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Repeated_Fixed64.Append (Value);
  end Add_Repeated_Fixed64;

  -- repeated sfixed32 repeated_sfixed32 = 39;
  function Repeated_Sfixed32_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Sfixed32.Length);
  end Repeated_Sfixed32_Size;

  procedure Clear_Repeated_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Sfixed32.Clear;
  end Clear_Repeated_Sfixed32;

  function Get_Repeated_Sfixed32
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Repeated_Sfixed32.Element (Index);
  end Get_Repeated_Sfixed32;

  procedure Set_Repeated_Sfixed32
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Sfixed32.Replace_Element (Index, Value);
  end Set_Repeated_Sfixed32;

  procedure Add_Repeated_Sfixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Repeated_Sfixed32.Append (Value);
  end Add_Repeated_Sfixed32;

  -- repeated sfixed64 repeated_sfixed64 = 40;
  function Repeated_Sfixed64_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Sfixed64.Length);
  end Repeated_Sfixed64_Size;

  procedure Clear_Repeated_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Sfixed64.Clear;
  end Clear_Repeated_Sfixed64;

  function Get_Repeated_Sfixed64
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Repeated_Sfixed64.Element (Index);
  end Get_Repeated_Sfixed64;

  procedure Set_Repeated_Sfixed64
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Sfixed64.Replace_Element (Index, Value);
  end Set_Repeated_Sfixed64;

  procedure Add_Repeated_Sfixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Repeated_Sfixed64.Append (Value);
  end Add_Repeated_Sfixed64;

  -- repeated float repeated_float = 41;
  function Repeated_Float_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Float.Length);
  end Repeated_Float_Size;

  procedure Clear_Repeated_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Float.Clear;
  end Clear_Repeated_Float;

  function Get_Repeated_Float
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Repeated_Float.Element (Index);
  end Get_Repeated_Float;

  procedure Set_Repeated_Float
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Repeated_Float.Replace_Element (Index, Value);
  end Set_Repeated_Float;

  procedure Add_Repeated_Float
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Repeated_Float.Append (Value);
  end Add_Repeated_Float;

  -- repeated double repeated_double = 42;
  function Repeated_Double_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Double.Length);
  end Repeated_Double_Size;

  procedure Clear_Repeated_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Double.Clear;
  end Clear_Repeated_Double;

  function Get_Repeated_Double
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Repeated_Double.Element (Index);
  end Get_Repeated_Double;

  procedure Set_Repeated_Double
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Repeated_Double.Replace_Element (Index, Value);
  end Set_Repeated_Double;

  procedure Add_Repeated_Double
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Repeated_Double.Append (Value);
  end Add_Repeated_Double;

  -- repeated bool repeated_bool = 43;
  function Repeated_Bool_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Bool.Length);
  end Repeated_Bool_Size;

  procedure Clear_Repeated_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Bool.Clear;
  end Clear_Repeated_Bool;

  function Get_Repeated_Bool
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_Bool is
  begin
    return The_Message.Repeated_Bool.Element (Index);
  end Get_Repeated_Bool;

  procedure Set_Repeated_Bool
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_Bool) is
  begin
    The_Message.Repeated_Bool.Replace_Element (Index, Value);
  end Set_Repeated_Bool;

  procedure Add_Repeated_Bool
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Bool) is
  begin
    The_Message.Repeated_Bool.Append (Value);
  end Add_Repeated_Bool;

  -- repeated string repeated_string = 44;
  function Repeated_String_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_String.Length);
  end Repeated_String_Size;

  procedure Clear_Repeated_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String.Clear;

  end Clear_Repeated_String;

  function Get_Repeated_String
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Repeated_String.Element (Index).all;
  end Get_Repeated_String;

  procedure Set_Repeated_String
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Repeated_String.Element (Index);
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      Free (Temp);
    end;
    The_Message.Repeated_String.Replace_Element (Index, new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Set_Repeated_String;

  procedure Add_Repeated_String
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Repeated_String.Append (new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Add_Repeated_String;

  -- repeated bytes repeated_bytes = 45;
  function Repeated_Bytes_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Bytes.Length);
  end Repeated_Bytes_Size;

  procedure Clear_Repeated_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Bytes loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Bytes.Clear;

  end Clear_Repeated_Bytes;

  function Get_Repeated_Bytes
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Repeated_Bytes.Element (Index).all;
  end Get_Repeated_Bytes;

  procedure Set_Repeated_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Repeated_Bytes.Element (Index);
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      Free (Temp);
    end;
    The_Message.Repeated_Bytes.Replace_Element (Index, new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Set_Repeated_Bytes;

  procedure Add_Repeated_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Repeated_Bytes.Append (new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Add_Repeated_Bytes;

  -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_nested_message = 48;
  function Repeated_Nested_Message_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Nested_Message.Length);
  end Repeated_Nested_Message_Size;

  procedure Clear_Repeated_Nested_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    for C in The_Message.Repeated_Nested_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Nested_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Nested_Message.Clear;

  end Clear_Repeated_Nested_Message;

  function Get_Repeated_Nested_Message
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return access Unittest.TestAllTypes.NestedMessage.Instance is
  begin
    return Unittest.TestAllTypes.NestedMessage.NestedMessage_Access (The_Message.Repeated_Nested_Message.Element (Index));
  end Get_Repeated_Nested_Message;

  function Add_Repeated_Nested_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access := new Unittest.TestAllTypes.NestedMessage.Instance;
  begin
    The_Message.Repeated_Nested_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
    return Temp;
  end Add_Repeated_Nested_Message;

  -- repeated .protobuf_unittest.ForeignMessage repeated_foreign_message = 49;
  function Repeated_Foreign_Message_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Foreign_Message.Length);
  end Repeated_Foreign_Message_Size;

  procedure Clear_Repeated_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    for C in The_Message.Repeated_Foreign_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Foreign_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Foreign_Message.Clear;

  end Clear_Repeated_Foreign_Message;

  function Get_Repeated_Foreign_Message
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return access Unittest.ForeignMessage.Instance is
  begin
    return Unittest.ForeignMessage.ForeignMessage_Access (The_Message.Repeated_Foreign_Message.Element (Index));
  end Get_Repeated_Foreign_Message;

  function Add_Repeated_Foreign_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ForeignMessage.Instance is
    Temp : Unittest.ForeignMessage.ForeignMessage_Access := new Unittest.ForeignMessage.Instance;
  begin
    The_Message.Repeated_Foreign_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
    return Temp;
  end Add_Repeated_Foreign_Message;

  -- repeated .protobuf_unittest_import.ImportMessage repeated_import_message = 50;
  function Repeated_Import_Message_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Import_Message.Length);
  end Repeated_Import_Message_Size;

  procedure Clear_Repeated_Import_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    for C in The_Message.Repeated_Import_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Import_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Import_Message.Clear;

  end Clear_Repeated_Import_Message;

  function Get_Repeated_Import_Message
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return access Unittest.ImportMessage.Instance is
  begin
    return Unittest.ImportMessage.ImportMessage_Access (The_Message.Repeated_Import_Message.Element (Index));
  end Get_Repeated_Import_Message;

  function Add_Repeated_Import_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.ImportMessage.Instance is
    Temp : Unittest.ImportMessage.ImportMessage_Access := new Unittest.ImportMessage.Instance;
  begin
    The_Message.Repeated_Import_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
    return Temp;
  end Add_Repeated_Import_Message;

  -- repeated .protobuf_unittest.TestAllTypes.NestedEnum repeated_nested_enum = 51;
  function Repeated_Nested_Enum_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Nested_Enum.Length);
  end Repeated_Nested_Enum_Size;

  procedure Clear_Repeated_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Nested_Enum.Clear;
  end Clear_Repeated_Nested_Enum;

  function Get_Repeated_Nested_Enum
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return NestedEnum is
  begin
    return PB_Int32_To_Enumeration(The_Message.Repeated_Nested_Enum.Element (Index));
  end Get_Repeated_Nested_Enum;

  procedure Set_Repeated_Nested_Enum
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in NestedEnum) is
  begin
    The_Message.Repeated_Nested_Enum.Replace_Element (Index, Enumeration_To_PB_Int32(Value));
  end Set_Repeated_Nested_Enum;

  procedure Add_Repeated_Nested_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in NestedEnum) is
  begin
    The_Message.Repeated_Nested_Enum.Append (Enumeration_To_PB_Int32 (Value));
  end Add_Repeated_Nested_Enum;

  -- repeated .protobuf_unittest.ForeignEnum repeated_foreign_enum = 52;
  function Repeated_Foreign_Enum_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Foreign_Enum.Length);
  end Repeated_Foreign_Enum_Size;

  procedure Clear_Repeated_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Foreign_Enum.Clear;
  end Clear_Repeated_Foreign_Enum;

  function Get_Repeated_Foreign_Enum
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return ForeignEnum is
  begin
    return PB_Int32_To_Enumeration(The_Message.Repeated_Foreign_Enum.Element (Index));
  end Get_Repeated_Foreign_Enum;

  procedure Set_Repeated_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in ForeignEnum) is
  begin
    The_Message.Repeated_Foreign_Enum.Replace_Element (Index, Enumeration_To_PB_Int32(Value));
  end Set_Repeated_Foreign_Enum;

  procedure Add_Repeated_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ForeignEnum) is
  begin
    The_Message.Repeated_Foreign_Enum.Append (Enumeration_To_PB_Int32 (Value));
  end Add_Repeated_Foreign_Enum;

  -- repeated .protobuf_unittest_import.ImportEnum repeated_import_enum = 53;
  function Repeated_Import_Enum_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Import_Enum.Length);
  end Repeated_Import_Enum_Size;

  procedure Clear_Repeated_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Repeated_Import_Enum.Clear;
  end Clear_Repeated_Import_Enum;

  function Get_Repeated_Import_Enum
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return ImportEnum is
  begin
    return PB_Int32_To_Enumeration(The_Message.Repeated_Import_Enum.Element (Index));
  end Get_Repeated_Import_Enum;

  procedure Set_Repeated_Import_Enum
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in ImportEnum) is
  begin
    The_Message.Repeated_Import_Enum.Replace_Element (Index, Enumeration_To_PB_Int32(Value));
  end Set_Repeated_Import_Enum;

  procedure Add_Repeated_Import_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ImportEnum) is
  begin
    The_Message.Repeated_Import_Enum.Append (Enumeration_To_PB_Int32 (Value));
  end Add_Repeated_Import_Enum;

  -- repeated string repeated_string_piece = 54 [ctype = STRING_PIECE];
  function Repeated_String_Piece_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_String_Piece.Length);
  end Repeated_String_Piece_Size;

  procedure Clear_Repeated_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_String_Piece loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_String_Piece.Clear;

  end Clear_Repeated_String_Piece;

  function Get_Repeated_String_Piece
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Repeated_String_Piece.Element (Index).all;
  end Get_Repeated_String_Piece;

  procedure Set_Repeated_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Repeated_String_Piece.Element (Index);
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      Free (Temp);
    end;
    The_Message.Repeated_String_Piece.Replace_Element (Index, new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Set_Repeated_String_Piece;

  procedure Add_Repeated_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Repeated_String_Piece.Append (new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Add_Repeated_String_Piece;

  -- repeated string repeated_cord = 55 [ctype = CORD];
  function Repeated_Cord_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Cord.Length);
  end Repeated_Cord_Size;

  procedure Clear_Repeated_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access;
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      for E of The_Message.Repeated_Cord loop
        Temp := E;
        Free (Temp);
      end loop;
    end;
    The_Message.Repeated_Cord.Clear;

  end Clear_Repeated_Cord;

  function Get_Repeated_Cord
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Repeated_Cord.Element (Index).all;
  end Get_Repeated_Cord;

  procedure Set_Repeated_Cord
    (The_Message : in out TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    declare
      Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Repeated_Cord.Element (Index);
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      Free (Temp);
    end;
    The_Message.Repeated_Cord.Replace_Element (Index, new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Set_Repeated_Cord;

  procedure Add_Repeated_Cord
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Repeated_Cord.Append (new Protocol_Buffers.Wire_Format.PB_String'(Value));
  end Add_Repeated_Cord;

  -- repeated .protobuf_unittest.TestAllTypes.NestedMessage repeated_lazy_message = 57 [lazy = true];
  function Repeated_Lazy_Message_Size
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return Protocol_Buffers.Wire_Format.PB_Object_Size (The_Message.Repeated_Lazy_Message.Length);
  end Repeated_Lazy_Message_Size;

  procedure Clear_Repeated_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) is
  begin
    for C in The_Message.Repeated_Lazy_Message.Iterate loop
      Protocol_Buffers.Message.Free (The_Message.Repeated_Lazy_Message.Reference (C).Element.all);
    end loop;
    The_Message.Repeated_Lazy_Message.Clear;

  end Clear_Repeated_Lazy_Message;

  function Get_Repeated_Lazy_Message
    (The_Message : in TestAllTypes.Instance;
     Index : in Protocol_Buffers.Wire_Format.PB_Object_Size) return access Unittest.TestAllTypes.NestedMessage.Instance is
  begin
    return Unittest.TestAllTypes.NestedMessage.NestedMessage_Access (The_Message.Repeated_Lazy_Message.Element (Index));
  end Get_Repeated_Lazy_Message;

  function Add_Repeated_Lazy_Message
    (The_Message : in out TestAllTypes.Instance) return access Unittest.TestAllTypes.NestedMessage.Instance is
    Temp : Unittest.TestAllTypes.NestedMessage.NestedMessage_Access := new Unittest.TestAllTypes.NestedMessage.Instance;
  begin
    The_Message.Repeated_Lazy_Message.Append (Protocol_Buffers.Message.Instance_Access (Temp));
    return Temp;
  end Add_Repeated_Lazy_Message;

  -- optional int32 default_int32 = 61 [default = 41];
  function Has_Default_Int32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00020000#) /= 0;
  end Has_Default_Int32;

  procedure Set_Has_Default_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00020000#;
  end Set_Has_Default_Int32;

  procedure Clear_Has_Default_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00020000#);
  end Clear_Has_Default_Int32;

  procedure Clear_Default_Int32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Int32 := 41;
    The_Message.Clear_Has_Default_Int32;
  end Clear_Default_Int32;

  function Get_Default_Int32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Default_Int32;
  end Get_Default_Int32;

  procedure Set_Default_Int32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Default_Int32;
    The_Message.Default_Int32 := Value;
  end Set_Default_Int32;

  -- optional int64 default_int64 = 62 [default = 42];
  function Has_Default_Int64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00040000#) /= 0;
  end Has_Default_Int64;

  procedure Set_Has_Default_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00040000#;
  end Set_Has_Default_Int64;

  procedure Clear_Has_Default_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00040000#);
  end Clear_Has_Default_Int64;

  procedure Clear_Default_Int64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Int64 := 42;
    The_Message.Clear_Has_Default_Int64;
  end Clear_Default_Int64;

  function Get_Default_Int64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Default_Int64;
  end Get_Default_Int64;

  procedure Set_Default_Int64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Default_Int64;
    The_Message.Default_Int64 := Value;
  end Set_Default_Int64;

  -- optional uint32 default_uint32 = 63 [default = 43];
  function Has_Default_Uint32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00080000#) /= 0;
  end Has_Default_Uint32;

  procedure Set_Has_Default_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00080000#;
  end Set_Has_Default_Uint32;

  procedure Clear_Has_Default_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00080000#);
  end Clear_Has_Default_Uint32;

  procedure Clear_Default_Uint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Uint32 := 43;
    The_Message.Clear_Has_Default_Uint32;
  end Clear_Default_Uint32;

  function Get_Default_Uint32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Default_Uint32;
  end Get_Default_Uint32;

  procedure Set_Default_Uint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Set_Has_Default_Uint32;
    The_Message.Default_Uint32 := Value;
  end Set_Default_Uint32;

  -- optional uint64 default_uint64 = 64 [default = 44];
  function Has_Default_Uint64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00100000#) /= 0;
  end Has_Default_Uint64;

  procedure Set_Has_Default_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00100000#;
  end Set_Has_Default_Uint64;

  procedure Clear_Has_Default_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00100000#);
  end Clear_Has_Default_Uint64;

  procedure Clear_Default_Uint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Uint64 := 44;
    The_Message.Clear_Has_Default_Uint64;
  end Clear_Default_Uint64;

  function Get_Default_Uint64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Default_Uint64;
  end Get_Default_Uint64;

  procedure Set_Default_Uint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Set_Has_Default_Uint64;
    The_Message.Default_Uint64 := Value;
  end Set_Default_Uint64;

  -- optional sint32 default_sint32 = 65 [default = -45];
  function Has_Default_Sint32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00200000#) /= 0;
  end Has_Default_Sint32;

  procedure Set_Has_Default_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00200000#;
  end Set_Has_Default_Sint32;

  procedure Clear_Has_Default_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00200000#);
  end Clear_Has_Default_Sint32;

  procedure Clear_Default_Sint32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Sint32 := -45;
    The_Message.Clear_Has_Default_Sint32;
  end Clear_Default_Sint32;

  function Get_Default_Sint32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Default_Sint32;
  end Get_Default_Sint32;

  procedure Set_Default_Sint32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Default_Sint32;
    The_Message.Default_Sint32 := Value;
  end Set_Default_Sint32;

  -- optional sint64 default_sint64 = 66 [default = 46];
  function Has_Default_Sint64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00400000#) /= 0;
  end Has_Default_Sint64;

  procedure Set_Has_Default_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00400000#;
  end Set_Has_Default_Sint64;

  procedure Clear_Has_Default_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00400000#);
  end Clear_Has_Default_Sint64;

  procedure Clear_Default_Sint64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Sint64 := 46;
    The_Message.Clear_Has_Default_Sint64;
  end Clear_Default_Sint64;

  function Get_Default_Sint64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Default_Sint64;
  end Get_Default_Sint64;

  procedure Set_Default_Sint64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Default_Sint64;
    The_Message.Default_Sint64 := Value;
  end Set_Default_Sint64;

  -- optional fixed32 default_fixed32 = 67 [default = 47];
  function Has_Default_Fixed32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#00800000#) /= 0;
  end Has_Default_Fixed32;

  procedure Set_Has_Default_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#00800000#;
  end Set_Has_Default_Fixed32;

  procedure Clear_Has_Default_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#00800000#);
  end Clear_Has_Default_Fixed32;

  procedure Clear_Default_Fixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Fixed32 := 47;
    The_Message.Clear_Has_Default_Fixed32;
  end Clear_Default_Fixed32;

  function Get_Default_Fixed32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Default_Fixed32;
  end Get_Default_Fixed32;

  procedure Set_Default_Fixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Set_Has_Default_Fixed32;
    The_Message.Default_Fixed32 := Value;
  end Set_Default_Fixed32;

  -- optional fixed64 default_fixed64 = 68 [default = 48];
  function Has_Default_Fixed64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#01000000#) /= 0;
  end Has_Default_Fixed64;

  procedure Set_Has_Default_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#01000000#;
  end Set_Has_Default_Fixed64;

  procedure Clear_Has_Default_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#01000000#);
  end Clear_Has_Default_Fixed64;

  procedure Clear_Default_Fixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Fixed64 := 48;
    The_Message.Clear_Has_Default_Fixed64;
  end Clear_Default_Fixed64;

  function Get_Default_Fixed64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Default_Fixed64;
  end Get_Default_Fixed64;

  procedure Set_Default_Fixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Set_Has_Default_Fixed64;
    The_Message.Default_Fixed64 := Value;
  end Set_Default_Fixed64;

  -- optional sfixed32 default_sfixed32 = 69 [default = 49];
  function Has_Default_Sfixed32
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#02000000#) /= 0;
  end Has_Default_Sfixed32;

  procedure Set_Has_Default_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#02000000#;
  end Set_Has_Default_Sfixed32;

  procedure Clear_Has_Default_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#02000000#);
  end Clear_Has_Default_Sfixed32;

  procedure Clear_Default_Sfixed32
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Sfixed32 := 49;
    The_Message.Clear_Has_Default_Sfixed32;
  end Clear_Default_Sfixed32;

  function Get_Default_Sfixed32
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Default_Sfixed32;
  end Get_Default_Sfixed32;

  procedure Set_Default_Sfixed32
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Default_Sfixed32;
    The_Message.Default_Sfixed32 := Value;
  end Set_Default_Sfixed32;

  -- optional sfixed64 default_sfixed64 = 70 [default = -50];
  function Has_Default_Sfixed64
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#04000000#) /= 0;
  end Has_Default_Sfixed64;

  procedure Set_Has_Default_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#04000000#;
  end Set_Has_Default_Sfixed64;

  procedure Clear_Has_Default_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#04000000#);
  end Clear_Has_Default_Sfixed64;

  procedure Clear_Default_Sfixed64
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Sfixed64 := -50;
    The_Message.Clear_Has_Default_Sfixed64;
  end Clear_Default_Sfixed64;

  function Get_Default_Sfixed64
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Default_Sfixed64;
  end Get_Default_Sfixed64;

  procedure Set_Default_Sfixed64
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Default_Sfixed64;
    The_Message.Default_Sfixed64 := Value;
  end Set_Default_Sfixed64;

  -- optional float default_float = 71 [default = 51.5];
  function Has_Default_Float
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#08000000#) /= 0;
  end Has_Default_Float;

  procedure Set_Has_Default_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#08000000#;
  end Set_Has_Default_Float;

  procedure Clear_Has_Default_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#08000000#);
  end Clear_Has_Default_Float;

  procedure Clear_Default_Float
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Float := Protocol_Buffers.Wire_Format.PB_Float (51.5000);
    The_Message.Clear_Has_Default_Float;
  end Clear_Default_Float;

  function Get_Default_Float
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Default_Float;
  end Get_Default_Float;

  procedure Set_Default_Float
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Default_Float;
    The_Message.Default_Float := Value;
  end Set_Default_Float;

  -- optional double default_double = 72 [default = 52000];
  function Has_Default_Double
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#10000000#) /= 0;
  end Has_Default_Double;

  procedure Set_Has_Default_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#10000000#;
  end Set_Has_Default_Double;

  procedure Clear_Has_Default_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#10000000#);
  end Clear_Has_Default_Double;

  procedure Clear_Default_Double
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Double := Protocol_Buffers.Wire_Format.PB_Double (52000.0000000000);
    The_Message.Clear_Has_Default_Double;
  end Clear_Default_Double;

  function Get_Default_Double
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Default_Double;
  end Get_Default_Double;

  procedure Set_Default_Double
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Set_Has_Default_Double;
    The_Message.Default_Double := Value;
  end Set_Default_Double;

  -- optional bool default_bool = 73 [default = true];
  function Has_Default_Bool
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#20000000#) /= 0;
  end Has_Default_Bool;

  procedure Set_Has_Default_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#20000000#;
  end Set_Has_Default_Bool;

  procedure Clear_Has_Default_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#20000000#);
  end Clear_Has_Default_Bool;

  procedure Clear_Default_Bool
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Bool := True;
    The_Message.Clear_Has_Default_Bool;
  end Clear_Default_Bool;

  function Get_Default_Bool
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_Bool is
  begin
    return The_Message.Default_Bool;
  end Get_Default_Bool;

  procedure Set_Default_Bool
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Bool) is
  begin
    The_Message.Set_Has_Default_Bool;
    The_Message.Default_Bool := Value;
  end Set_Default_Bool;

  -- optional string default_string = 74 [default = "hello"];
  function Has_Default_String
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#40000000#) /= 0;
  end Has_Default_String;

  procedure Set_Has_Default_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#40000000#;
  end Set_Has_Default_String;

  procedure Clear_Has_Default_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#40000000#);
  end Clear_Has_Default_String;

  procedure Clear_Default_String
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Default_String;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_String /= Default_Default_String'Access then
        Free (The_Message.Default_String);
      end if;
    end;
    The_Message.Default_String := Default_Default_String'Access;
    The_Message.Clear_Has_Default_String;
  end Clear_Default_String;

  function Get_Default_String
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Default_String.all;
  end Get_Default_String;

  function Get_Default_String
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Default_String;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_String /= Default_Default_String'Access then
          Free (The_Message.Default_String);
        end if;
      end;
      The_Message.Default_String := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Default_String;
    end if;

    if The_Message.Default_String = Default_Default_String'Access then
      The_Message.Default_String := new String'(Default_Default_String);
    end if;
    return The_Message.Default_String;
  end Get_Default_String;

  procedure Set_Default_String
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Default_String;
    if The_Message.Default_String /= Default_Default_String'Access and then Value'Length = The_Message.Default_String.all'Length then
      The_Message.Default_String.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_String /= Default_Default_String'Access then
          Free (The_Message.Default_String);
        end if;
      end;
      The_Message.Default_String := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Default_String;

  function Release_Default_String
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Default_String;
    if The_Message.Default_String = Default_Default_String'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Default_String;
      begin
        The_Message.Default_String := Default_Default_String'Access;
        return Temp;
      end;
    end if;
  end Release_Default_String;

  -- optional bytes default_bytes = 75 [default = "world"];
  function Has_Default_Bytes
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(1) and 16#80000000#) /= 0;
  end Has_Default_Bytes;

  procedure Set_Has_Default_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) or 16#80000000#;
  end Set_Has_Default_Bytes;

  procedure Clear_Has_Default_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(1) := The_Message.Has_Bits(1) and (not 16#80000000#);
  end Clear_Has_Default_Bytes;

  procedure Clear_Default_Bytes
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Default_Bytes;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
        Free (The_Message.Default_Bytes);
      end if;
    end;
    The_Message.Default_Bytes := Default_Default_Bytes'Access;
    The_Message.Clear_Has_Default_Bytes;
  end Clear_Default_Bytes;

  function Get_Default_Bytes
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Default_Bytes.all;
  end Get_Default_Bytes;

  function Get_Default_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Default_Bytes;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
          Free (The_Message.Default_Bytes);
        end if;
      end;
      The_Message.Default_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Default_Bytes;
    end if;

    if The_Message.Default_Bytes = Default_Default_Bytes'Access then
      The_Message.Default_Bytes := new String'(Default_Default_Bytes);
    end if;
    return The_Message.Default_Bytes;
  end Get_Default_Bytes;

  procedure Set_Default_Bytes
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Default_Bytes;
    if The_Message.Default_Bytes /= Default_Default_Bytes'Access and then Value'Length = The_Message.Default_Bytes.all'Length then
      The_Message.Default_Bytes.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_Bytes /= Default_Default_Bytes'Access then
          Free (The_Message.Default_Bytes);
        end if;
      end;
      The_Message.Default_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Default_Bytes;

  function Release_Default_Bytes
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Default_Bytes;
    if The_Message.Default_Bytes = Default_Default_Bytes'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Default_Bytes;
      begin
        The_Message.Default_Bytes := Default_Default_Bytes'Access;
        return Temp;
      end;
    end if;
  end Release_Default_Bytes;

  -- optional .protobuf_unittest.TestAllTypes.NestedEnum default_nested_enum = 81 [default = BAR];
  function Has_Default_Nested_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(2) and 16#00000001#) /= 0;
  end Has_Default_Nested_Enum;

  procedure Set_Has_Default_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) or 16#00000001#;
  end Set_Has_Default_Nested_Enum;

  procedure Clear_Has_Default_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) and (not 16#00000001#);
  end Clear_Has_Default_Nested_Enum;

  procedure Clear_Default_Nested_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Nested_Enum := NestedEnum'(BAR);
    The_Message.Clear_Has_Default_Nested_Enum;
  end Clear_Default_Nested_Enum;

  function Get_Default_Nested_Enum
    (The_Message : in TestAllTypes.Instance) return NestedEnum is
  begin
    return The_Message.Default_Nested_Enum;
  end Get_Default_Nested_Enum;

  procedure Set_Default_Nested_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in NestedEnum) is
  begin
    Set_Has_Default_Nested_Enum (The_Message);
    The_Message.Default_Nested_Enum := Value;
  end Set_Default_Nested_Enum;

  -- optional .protobuf_unittest.ForeignEnum default_foreign_enum = 82 [default = FOREIGN_BAR];
  function Has_Default_Foreign_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(2) and 16#00000002#) /= 0;
  end Has_Default_Foreign_Enum;

  procedure Set_Has_Default_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) or 16#00000002#;
  end Set_Has_Default_Foreign_Enum;

  procedure Clear_Has_Default_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) and (not 16#00000002#);
  end Clear_Has_Default_Foreign_Enum;

  procedure Clear_Default_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Foreign_Enum := ForeignEnum'(FOREIGN_BAR);
    The_Message.Clear_Has_Default_Foreign_Enum;
  end Clear_Default_Foreign_Enum;

  function Get_Default_Foreign_Enum
    (The_Message : in TestAllTypes.Instance) return ForeignEnum is
  begin
    return The_Message.Default_Foreign_Enum;
  end Get_Default_Foreign_Enum;

  procedure Set_Default_Foreign_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ForeignEnum) is
  begin
    Set_Has_Default_Foreign_Enum (The_Message);
    The_Message.Default_Foreign_Enum := Value;
  end Set_Default_Foreign_Enum;

  -- optional .protobuf_unittest_import.ImportEnum default_import_enum = 83 [default = IMPORT_BAR];
  function Has_Default_Import_Enum
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(2) and 16#00000004#) /= 0;
  end Has_Default_Import_Enum;

  procedure Set_Has_Default_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) or 16#00000004#;
  end Set_Has_Default_Import_Enum;

  procedure Clear_Has_Default_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) and (not 16#00000004#);
  end Clear_Has_Default_Import_Enum;

  procedure Clear_Default_Import_Enum
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Default_Import_Enum := ImportEnum'(IMPORT_BAR);
    The_Message.Clear_Has_Default_Import_Enum;
  end Clear_Default_Import_Enum;

  function Get_Default_Import_Enum
    (The_Message : in TestAllTypes.Instance) return ImportEnum is
  begin
    return The_Message.Default_Import_Enum;
  end Get_Default_Import_Enum;

  procedure Set_Default_Import_Enum
    (The_Message : in out TestAllTypes.Instance;
     Value : in ImportEnum) is
  begin
    Set_Has_Default_Import_Enum (The_Message);
    The_Message.Default_Import_Enum := Value;
  end Set_Default_Import_Enum;

  -- optional string default_string_piece = 84 [default = "abc", ctype = STRING_PIECE];
  function Has_Default_String_Piece
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(2) and 16#00000008#) /= 0;
  end Has_Default_String_Piece;

  procedure Set_Has_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) or 16#00000008#;
  end Set_Has_Default_String_Piece;

  procedure Clear_Has_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) and (not 16#00000008#);
  end Clear_Has_Default_String_Piece;

  procedure Clear_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Default_String_Piece;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
        Free (The_Message.Default_String_Piece);
      end if;
    end;
    The_Message.Default_String_Piece := Default_Default_String_Piece'Access;
    The_Message.Clear_Has_Default_String_Piece;
  end Clear_Default_String_Piece;

  function Get_Default_String_Piece
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Default_String_Piece.all;
  end Get_Default_String_Piece;

  function Get_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Default_String_Piece;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
          Free (The_Message.Default_String_Piece);
        end if;
      end;
      The_Message.Default_String_Piece := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Default_String_Piece;
    end if;

    if The_Message.Default_String_Piece = Default_Default_String_Piece'Access then
      The_Message.Default_String_Piece := new String'(Default_Default_String_Piece);
    end if;
    return The_Message.Default_String_Piece;
  end Get_Default_String_Piece;

  procedure Set_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Default_String_Piece;
    if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access and then Value'Length = The_Message.Default_String_Piece.all'Length then
      The_Message.Default_String_Piece.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_String_Piece /= Default_Default_String_Piece'Access then
          Free (The_Message.Default_String_Piece);
        end if;
      end;
      The_Message.Default_String_Piece := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Default_String_Piece;

  function Release_Default_String_Piece
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Default_String_Piece;
    if The_Message.Default_String_Piece = Default_Default_String_Piece'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Default_String_Piece;
      begin
        The_Message.Default_String_Piece := Default_Default_String_Piece'Access;
        return Temp;
      end;
    end if;
  end Release_Default_String_Piece;

  -- optional string default_cord = 85 [default = "123", ctype = CORD];
  function Has_Default_Cord
    (The_Message : in TestAllTypes.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(2) and 16#00000010#) /= 0;
  end Has_Default_Cord;

  procedure Set_Has_Default_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) or 16#00000010#;
  end Set_Has_Default_Cord;

  procedure Clear_Has_Default_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Has_Bits(2) := The_Message.Has_Bits(2) and (not 16#00000010#);
  end Clear_Has_Default_Cord;

  procedure Clear_Default_Cord
    (The_Message : in out TestAllTypes.Instance) is
  begin
    The_Message.Clear_Has_Default_Cord;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Default_Cord /= Default_Default_Cord'Access then
        Free (The_Message.Default_Cord);
      end if;
    end;
    The_Message.Default_Cord := Default_Default_Cord'Access;
    The_Message.Clear_Has_Default_Cord;
  end Clear_Default_Cord;

  function Get_Default_Cord
    (The_Message : in TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Default_Cord.all;
  end Get_Default_Cord;

  function Get_Default_Cord
    (The_Message : in out TestAllTypes.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Default_Cord;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_Cord /= Default_Default_Cord'Access then
          Free (The_Message.Default_Cord);
        end if;
      end;
      The_Message.Default_Cord := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Default_Cord;
    end if;

    if The_Message.Default_Cord = Default_Default_Cord'Access then
      The_Message.Default_Cord := new String'(Default_Default_Cord);
    end if;
    return The_Message.Default_Cord;
  end Get_Default_Cord;

  procedure Set_Default_Cord
    (The_Message : in out TestAllTypes.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Default_Cord;
    if The_Message.Default_Cord /= Default_Default_Cord'Access and then Value'Length = The_Message.Default_Cord.all'Length then
      The_Message.Default_Cord.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Default_Cord /= Default_Default_Cord'Access then
          Free (The_Message.Default_Cord);
        end if;
      end;
      The_Message.Default_Cord := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Default_Cord;

  function Release_Default_Cord
    (The_Message : in out TestAllTypes.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Default_Cord;
    if The_Message.Default_Cord = Default_Default_Cord'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Default_Cord;
      begin
        The_Message.Default_Cord := Default_Default_Cord'Access;
        return Temp;
      end;
    end if;
  end Release_Default_Cord;

end Unittest.TestAllTypes;
