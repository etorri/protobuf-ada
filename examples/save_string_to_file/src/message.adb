-- Generated by the protocol buffer compiler. DO NOT EDIT!
-- source: message.proto

pragma Ada_2012;
with Protocol_Buffers.Wire_Format;
with Ada.Strings.Unbounded;

package body Message is

  package body Person is

    ---------------------------------------------------------------------------
    -- Inherited functions and procedures from Protocol_Buffers.Message -------
    ---------------------------------------------------------------------------

    procedure Clear
      (The_Message : in out Person.Instance) is
    begin
      if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
        The_Message.Id := 0;
        if The_Message.Has_Name then
          pragma Compile_Time_Warning (Standard.True, "Clear for message and string not implemented!");
        end if;
      end if;
      The_Message.Has_Bits := (others => 0);
    end Clear;

    procedure Copy
      (To   : in out Person.Instance;
       From : in Person.Instance) is
    begin
      pragma Compile_Time_Warning (Standard.True, "Copy not implemented!");
      null;
    end Copy;

    function Get_Type_Name
      (The_Message : in Person.Instance) return Protocol_Buffers.Wire_Format.TMP_STRING is
    begin
      return "Person";
    end Get_Type_Name;

    function Is_Initialized
      (The_Message : in Person.Instance) return Boolean is
    begin
      if (The_Message.Has_Bits(0) and 16#00000001#) /= 16#00000001# then return False; end if;
      return True;
    end Is_Initialized;

    procedure Merge
      (To   : in out Person.Instance;
       From : in Person.Instance) is
    begin
      if (From.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
        -- required int32 id = 1;
        if From.Has_Id then
          To.Set_Id (From.Id);
        end if;
        -- optional string name = 2;
            if From.Has_Name then
--               To.Set_Name (Protocol_Buffers.Wire_Format.TMP_String (Ada.Strings.Unbounded.To_String (From.Name));
               To.Name := From.Name;
        end if;
      end if;
    end Merge;

    function Byte_Size
      (The_Message : in out Person.Instance) return Protocol_Buffers.Wire_Format.TMP_OBJECT_SIZE is
      Total_Size : Protocol_Buffers.Wire_Format.TMP_OBJECT_SIZE := 0;
    begin
      -- required int32 id = 1;
      if The_Message.Has_Id then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (The_Message.Id);
      end if;
      -- optional string name = 2;
         if The_Message.Has_Name then
            declare
               asdf : Natural := Ada.Strings.Unbounded.Length(The_Message.Name);
            begin
               null;
            end;
           Total_Size := Total_Size + Protocol_Buffers.Wire_Format.TMP_OBJECT_SIZE(Ada.Strings.Unbounded.Length(The_Message.Name));
      end if;
      The_Message.Cached_Size := Total_Size;
      return Total_Size;
    end Byte_Size;

    procedure Serialize_With_Cached_Sizes
      (The_Message   : in Person.Instance;
       The_Coded_Output_Stream : in
         Protocol_Buffers.IO.Coded_Output_Stream.Instance) is
    begin
      -- required int32 id = 1;
      if The_Message.Has_Id then
        Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 1, The_Message.Id);
      end if;
      -- optional string name = 2;
      if The_Message.Has_Name then
        Protocol_Buffers.IO.Coded_Output_Stream.Write_String (The_Coded_Output_Stream, 2, The_Message.Name);
      end if;
    end Serialize_With_Cached_Sizes;

    procedure Merge_Partial_From_Coded_Input_Stream
      (The_Message   : in out Person.Instance;
       The_Coded_Input_Stream : in
         Protocol_Buffers.IO.Coded_Input_Stream.Instance) is
      Tag : Protocol_Buffers.Wire_Format.TMP_UNSIGNED_INTEGER;
    begin
      Tag := The_Coded_Input_Stream.Read_Tag;
      while Tag /= 0 loop
        case Protocol_Buffers.Wire_Format.Get_Tag_Field_Number (Tag) is
        -- required int32 id = 1;
        when 1 =>
          if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
            Protocol_Buffers.Wire_Format.VARINT then
            The_Message.Id := The_Coded_Input_Stream.Read_Integer_32;
            The_Message.Set_Has_Id;
          end if;
        -- optional string name = 2;
        when 2 =>
               if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
                 Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
                  The_Message.Name := The_Coded_Input_Stream.Read_String;
                  The_Message.Set_Has_Name;
               end if;
        when others =>
          pragma Compile_Time_Warning (Standard.True, "Error handling not implemented for Merge_Partial_From_Coded_Input_Stream!");
        end case;
        Tag := The_Coded_Input_Stream.Read_Tag;
      end loop;
    end Merge_Partial_From_Coded_Input_Stream;

    function Get_Cached_Size
      (The_Message : in Person.Instance) return Protocol_Buffers.Wire_Format.TMP_OBJECT_SIZE is
    begin
      return The_Message.Cached_Size;
    end Get_Cached_Size;

    ---------------------------------------------------------------------------
    -- Field accessor definitions ---------------------------------------------
    ---------------------------------------------------------------------------

    -- required int32 id = 1;
    function Has_Id
      (The_Message : in Person.Instance) return Boolean is
    begin
      return (The_Message.Has_Bits(0) and 16#00000001#) /= 0;
    end Has_Id;

    procedure Set_Has_Id
      (The_Message : in out Person.Instance) is
    begin
      The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000001#;
    end Set_Has_Id;

    procedure Clear_Has_Id
      (The_Message : in out Person.Instance) is
    begin
      The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000001#);
    end Clear_Has_Id;

    procedure Clear_Id
      (The_Message : in out Person.Instance) is
    begin
      The_Message.Id := 0;
    end Clear_Id;

    function Id
      (The_Message : in Person.Instance) return Protocol_Buffers.Wire_Format.TMP_INTEGER is
    begin
      return The_Message.Id;
    end Id;

    procedure Set_Id
      (The_Message : in out Person.Instance;
       Value : in Protocol_Buffers.Wire_Format.TMP_INTEGER) is
    begin
      Set_Has_Id (The_Message);
      The_Message.Id := Value;
    end Set_Id;

    -- optional string name = 2;
    function Has_Name
      (The_Message : in Person.Instance) return Boolean is
    begin
      return (The_Message.Has_Bits(0) and 16#00000002#) /= 0;
    end Has_Name;

    procedure Set_Has_Name
      (The_Message : in out Person.Instance) is
    begin
      The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000002#;
    end Set_Has_Name;

    procedure Clear_Has_Name
      (The_Message : in out Person.Instance) is
    begin
      The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000002#);
    end Clear_Has_Name;

    procedure Clear_Name
      (The_Message : in out Person.Instance) is
      begin
         The_Message.Name := Ada.Strings.Unbounded.To_Unbounded_String("");
    end Clear_Name;

    function Name
      (The_Message : in Person.Instance) return Protocol_Buffers.Wire_Format.TMP_STRING is
    begin
      return Protocol_Buffers.Wire_Format.TMP_STRING(Ada.Strings.Unbounded.To_String(The_Message.Name));
    end Name;

    procedure Set_Name
      (The_Message : in out Person.Instance;
       Value : in Protocol_Buffers.Wire_Format.TMP_STRING) is
      begin
         Set_Has_Name (The_Message);
         The_Message.Name := Ada.Strings.Unbounded.To_Unbounded_String(String(Value));
    end Set_Name;

  end Person;

end Message;
